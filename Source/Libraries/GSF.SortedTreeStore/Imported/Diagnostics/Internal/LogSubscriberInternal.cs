//******************************************************************************************************
//  LogSubscriberInternal.cs - Gbtc
//
//  Copyright © 2016, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the Eclipse Public License -v 1.0 (the "License"); you may
//  not use this file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://www.opensource.org/licenses/eclipse-1.0.php
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/24/2016 - Steven E. Chisholm
//       Generated original version of source code. 
//       
//
//******************************************************************************************************

using System;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable InconsistentlySynchronizedField

namespace GSF.Diagnostics
{
    /// <summary>
    /// A <see cref="LogSubscriberInternal"/> that collects logs 
    /// </summary>
    internal class LogSubscriberInternal
    {
        private class SubscriptionInfo
        {
            public PublisherFilter PublisherFilter;
            public MessageAttributeFilter AttributeFilter;
            public bool IsIgnoreSubscription;

            public SubscriptionInfo(PublisherFilter publisherFilter, MessageAttributeFilter attributeFilter, bool isIgnoreSubscription)
            {
                PublisherFilter = publisherFilter;
                AttributeFilter = attributeFilter;
                IsIgnoreSubscription = isIgnoreSubscription;
            }
        }

        /// <summary>
        /// Event handler for the logs that are raised.
        /// </summary>
        /// <remarks>
        /// Any exceptions generated by this callback will be ignored.
        /// </remarks>
        public event NewLogMessageEventHandler NewLogMessage;

        private Action m_subscriptionChanged;

        private readonly object m_syncRoot;

        private bool m_disposed;

        private List<SubscriptionInfo> m_allSubscriptions;

        private Dictionary<LogPublisherInternal, MessageAttributeFilter> m_publisherCache;

        /// <summary>
        /// Creates a <see cref="LogSubscriberInternal"/>
        /// </summary>
        public LogSubscriberInternal(Action subscriptionChanged)
        {
            m_subscriptionChanged = subscriptionChanged;
            m_syncRoot = new object();
            m_allSubscriptions = null;
            m_publisherCache = null;
        }

        /// <summary>
        /// Clears all subscriptions
        /// </summary>
        public void Clear()
        {
            if (m_disposed)
                return;

            lock (m_syncRoot)
            {
                if (m_disposed)
                    return;

                m_allSubscriptions = null;
                m_publisherCache = null;
            }
        }

        /// <summary>
        /// Adds/Modify/Deletes an existing subscription
        /// </summary>
        public void Subscribe(PublisherFilter publisherFilter, MessageAttributeFilter attributeFilter, bool isIgnoreSubscription)
        {
            if (publisherFilter == null)
                throw new ArgumentNullException(nameof(publisherFilter));

            if (m_disposed)
                return;

            bool hasChanged;

            lock (m_syncRoot)
            {
                if (m_disposed)
                    return;

                hasChanged = AddSubscriptionSync(publisherFilter, attributeFilter, isIgnoreSubscription);
                if (hasChanged)
                    m_publisherCache = null;
            }

            if (hasChanged)
                m_subscriptionChanged();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="publisherFilter"></param>
        /// <returns>True if subscription has changed, false otherwise</returns>
        private bool AddSubscriptionSync(PublisherFilter publisherFilter, MessageAttributeFilter attributeFilter, bool isIgnoreSubscription)
        {
            if (m_allSubscriptions == null)
            {
                if (attributeFilter == null)
                    return false;

                m_allSubscriptions = new List<SubscriptionInfo>();
                m_allSubscriptions.Add(new SubscriptionInfo(publisherFilter, attributeFilter, isIgnoreSubscription));
                return true;
            }
            else
            {
                for (int x = 0; x < m_allSubscriptions.Count; x++)
                {
                    if (m_allSubscriptions[x].PublisherFilter.ContainsTheSameLogSearchCriteria(publisherFilter))
                    {
                        if (attributeFilter == null)
                        {
                            m_allSubscriptions.RemoveAt(x);
                            return true;
                        }
                        m_allSubscriptions[x].AttributeFilter = attributeFilter;
                        m_allSubscriptions[x].IsIgnoreSubscription = isIgnoreSubscription;
                        return true;
                    }
                }
                if (attributeFilter == null)
                    return false;

                m_allSubscriptions.Add(new SubscriptionInfo(publisherFilter, attributeFilter, isIgnoreSubscription));
                return true;
            }

        }

        /// <summary>
        /// Assigns the supplied message to this subscriber.
        /// </summary>
        /// <param name="log">the message</param>
        /// <param name="publisher">the publisher that raised this message.</param>
        public void RaiseLogMessages(LogMessage log, LogPublisherInternal publisher)
        {
            if (m_disposed)
                return;

            lock (m_syncRoot)
            {
                if (m_disposed)
                    return;

                if (m_allSubscriptions == null || m_allSubscriptions.Count == 0)
                    return;

                MessageAttributeFilter verbose = GetSubscriptionSync(publisher);
                if (verbose.IsSubscribedTo(log.LogMessageAttributes))
                {
                    OnLog(log);
                }
            }
        }

        public MessageAttributeFilter GetSubscription(LogPublisherInternal publisher)
        {
            lock (m_syncRoot)
            {
                return GetSubscriptionSync(publisher);
            }
        }

        private MessageAttributeFilter GetSubscriptionSync(LogPublisherInternal publisher)
        {
            if (m_publisherCache == null)
                m_publisherCache = new Dictionary<LogPublisherInternal, MessageAttributeFilter>();
            if (m_allSubscriptions == null)
                m_allSubscriptions = new List<SubscriptionInfo>();

            MessageAttributeFilter verbose;
            if (!m_publisherCache.TryGetValue(publisher, out verbose))
            {
                verbose = new MessageAttributeFilter();

                foreach (var subscription in m_allSubscriptions)
                {
                    if (subscription.PublisherFilter.ContainsPublisher(publisher))
                    {
                        if (subscription.IsIgnoreSubscription)
                        {
                            verbose.Remove(subscription.AttributeFilter);
                        }
                        else
                        {
                            verbose.Append(subscription.AttributeFilter);
                        }
                    }
                }

                m_publisherCache.Add(publisher, verbose);
            }
            return verbose;
        }

        /// <summary>
        /// Raises the <see cref="NewLogMessage"/> event.
        /// </summary>
        /// <param name="logMessage">the message to raise.</param>
        private void OnLog(LogMessage logMessage)
        {
            if (logMessage == null)
                return;
            try
            {
                NewLogMessage?.Invoke(logMessage);
            }
            catch (Exception ex)
            {
                ex = ex;
                //Swallow this exception
                //This is because if a subscriber throws an exception, creating a new log
                //might cause an infinite loop.
            }
        }

        /// <summary>
        /// Disposes this class so future messages will not route. 
        /// </summary>
        public void Dispose()
        {
            m_disposed = true;
            m_allSubscriptions = null;
            m_publisherCache = null;
        }

        public static readonly LogSubscriberInternal DisposedSubscriber;

        static LogSubscriberInternal()
        {
            DisposedSubscriber = new LogSubscriberInternal(null);
            DisposedSubscriber.Dispose();
        }


    }
}