@*******************************************************************************************************
//  AddSynchrophasorDevice.cshtml - Gbtc
//
//  Copyright © 2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  02/18/2019 - J. Ritchie Carroll
//       Generated original version of source code.
//
//*****************************************************************************************************@
@using System.Net.Http
@using System.Threading
@using GSF.ComponentModel.DataAnnotations
@using GSF.Identity
@using GSF.Security
@using GSF.Web
@using GSF.Web.Model
@using GSF.Web.Shared
@using openHistorian
@using openHistorian.Model
@inherits ExtendedTemplateBase<AppModel>
@{
    Layout = "Layout.cshtml";
    ViewBag.HidePageTitle = true;
    ViewBag.Title = "New Device Commissioning Wizard";

    HttpRequestMessage request = ViewBag.Request;
    Dictionary<string, string> parameters = request.QueryParameters();
    string parameter;
    int deviceID;

    if (!parameters.TryGetValue("DeviceID", out parameter) || !int.TryParse(parameter, out deviceID)) {
        deviceID = 0;
    }

    bool userIsEditor = UserIsEditor();
}
@section StyleSheets {
    <style>
        html, body {
            height: 100%;
        }

        span.table-cell-text {
            display: table-cell;
            vertical-align: middle;
        }

        .input-label {
            text-align: right;
            vertical-align: top;
            padding: 6px;
            width: 160px;
        }

        .input-area {
            width: 80%;
            display: inline-table;
            vertical-align: middle;
        }

        .device-singleton {
            display: inherit;
        }

        @@media screen {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -38px;
            }
        }

        @@media screen and (min-width: 638px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }
        }

        @@media screen and (min-width: 868px) {
            .page-logo {
                margin-bottom: 2px;
                margin-top: -12px;
            }
        }

        @@media screen and (min-width: 992px) {
            .page-logo {
                margin-bottom: -25px;
                margin-top: -4px;
            }
        }
    </style>
}
@functions {
    public string GetCurrentUserID()
    {
        if ((object)Thread.CurrentPrincipal.Identity == null)
            return UserInfo.CurrentUserID;

        return Thread.CurrentPrincipal.Identity.Name;
    }

    // This function simply limits access to UI elements that the user does not have access to, server-side
    // functions will further validate user rights even if UI restriction was somehow bypassed
    public bool UserIsEditor()
    {
        SecurityPrincipal securityPrincipal = ViewBag.SecurityPrincipal as SecurityPrincipal;

        if ((object)securityPrincipal == null)
            return false;

        return securityPrincipal.IsInRole("Administrator") || securityPrincipal.IsInRole("Editor");
    }
}
@section Scripts {
    <script src="@Resources.Root/Shared/Scripts/knockout.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.mapping.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.validation.js"></script>
    <script src="@Resources.Root/Shared/Scripts/knockout.reactor.js"></script>
    <script src="@Resources.Root/Shared/Scripts/gsf.web.knockout.js"></script>
    <script>
        "use script";

        var firstConnect = true;
        var deviceID = @deviceID;
        var nodeID = "@Program.Host.Model.Global.NodeID";
        var viewModel = null;
        var deviceSignalTypes = [];
        var phasorSignalTypes = [];

        function showLoadingLabel() {
            $("#loadingDataLabel").css("visibility", "visible");
        }

        function hideLoadingLabel() {
            setTimeout(function () { $("#loadingDataLabel").css("visibility", "hidden"); }, 500);
        }

        function guessPhase(phasorLabel) {
            if (phasorLabel.indexOf("_V1") > -1 || phasorLabel.indexOf("_I1") > -1 || phasorLabel.indexOf(" POS ") > -1)
                return "+";

            if (phasorLabel.indexOf("_VA") > -1 || phasorLabel.indexOf("_IA") > -1 || phasorLabel.indexOf(" A ") > -1)
                return "A";

            if (phasorLabel.indexOf("_VB") > -1 || phasorLabel.indexOf("_IB") > -1 || phasorLabel.indexOf(" B ") > -1)
                return "B";

            if (phasorLabel.indexOf("_VC") > -1 || phasorLabel.indexOf("_IC") > -1 || phasorLabel.indexOf(" C ") > -1)
                return "C";

            if (phasorLabel.indexOf("_VN") > -1 || phasorLabel.indexOf("_IN") > -1 || phasorLabel.indexOf(" NEUT ") > -1)
                return "N";

            if (phasorLabel.indexOf("_V0") > -1 || phasorLabel.indexOf("_I0") > -1 || phasorLabel.indexOf(" ZERO ") > -1)
                return "0";

            if (phasorLabel.indexOf("_V2") > -1 || phasorLabel.indexOf("_I2") > -1 || phasorLabel.indexOf(" NEG ") > -1)
                return "-";

            return "+";
        }

        function guessNominalVoltage(phasorLabel, deviceLabel) {
            const commonVoltageLevels = ["69", "115", "230", "500", "765"];

            // Check phasor label before device
            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (phasorLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            for (let i = 0; i < commonVoltageLevels.length; i++) {
                const voltageLevel = commonVoltageLevels[i];

                if (deviceLabel.indexOf(voltageLevel) > -1)
                    return parseInt(voltageLevel);
            }

            return 500;
        }

        function guessAssociatedVoltage(voltages, phasorLabel, phase) {
            phasorLabel = phasorLabel.toUpperCase();

            if (phase === "+")
                phase = "1";
            else if (phase === "-")
                phase = "2";

            var search = "V" + phase;
            var replace = "I" + phase;

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            search = "POT";
            replace = "CURR";

            for (let i = 0; i < voltages.length; i++) {
                if (phasorLabel === voltages[i].Label().toUpperCase().replace(search, replace))
                    return voltages[i].ID;
            }

            var aCount = 0, aID = -1;
            var bCount = 0, bID = -1;
            var cCount = 0, cID = -1;
            var posCount = 0, posID = -1;
            var negCount = 0, negID = -1;
            var zCount = 0, zID = -1;
            var nCount = 0, nID = -1;

            for (let i = 0; i < voltages.length; i++) {
                const voltageID = voltages[i].ID;

                switch (voltages[i].Phase().toUpperCase()) {
                    case "A":
                        aCount++;
                        aID = voltageID;
                        break;
                    case "B":
                        bCount++;
                        bID = voltageID;
                        break;
                    case "C":
                        cCount++;
                        cID = voltageID;
                        break;
                    case "+":
                        posCount++;
                        posID = voltageID;
                        break;
                    case "-":
                        negCount++;
                        negID = voltageID;
                        break;
                    case "0":
                        zCount++;
                        zID = voltageID;
                        break;
                    case "N":
                        nCount++;
                        nID = voltageID;
                        break;
                }
            }

            switch (phase) {
                case "A":
                    if (aCount === 1)
                        return aID;
                    break;
                case "B":
                    if (bCount === 1)
                        return bID;
                    break;
                case "C":
                    if (cCount === 1)
                        return cID;
                    break;
                case "1":
                    if (posCount === 1)
                        return posID;
                    break;
                case "2":
                    if (negCount === 1)
                        return negID;
                    break;
                case "0":
                    if (zCount === 1)
                        return zID;
                    break;
                case "N":
                    if (nCount === 1)
                        return nID;
                break;
            }

            return -1;
        }

        function DeviceViewModel() {
            const self = this;

            // Observable fields
            self.voltages = ko.observableArray();
            self.currents = ko.observableArray();
            self.configFrame = ko.observable({ConnectionString: "", Cells: []});
            self.configFrameDetails = ko.observable("Calculating...");
            self.addAnalogs = ko.observable(false);
            self.addDigitals = ko.observable(false);
            self.errors = ko.validation.group(self);

            // Regular fields
            self.voltageCount = 0;

            // Internal fields
            self._addTagsAsVirtualPoints = ko.observable(undefined);
            self._deviceAcronym = ko.observable("DEVICENAME");
            self._instanceName = ko.observable("");
            self._templateType = ko.observable("");
            self._historianID = ko.observable(0);
            self._dataHubIsConnected = ko.observable(false);
            self._isDirty = ko.observable(false);

            // Properties
            self.addTagsAsVirtualPoints = ko.pureComputed({
                read: function () {
                    if (self._addTagsAsVirtualPoints() === undefined)
                        self._addTagsAsVirtualPoints(Cookies.get("addTagsAsVirtualPoints") === "true");

                    return self._addTagsAsVirtualPoints();
                },
                write: function (value) {
                    if (value === self._addTagsAsVirtualPoints())
                        return;

                    self._addTagsAsVirtualPoints(value);
                    Cookies.set("addTagsAsVirtualPoints", value.toString(), { expires: 365 });
                },
                owner: self
            });

            self.editMode = ko.pureComputed({
                read: function () {
                    return deviceID > 0;
                }
            });

            self.deviceAcronym = ko.pureComputed({
                read: self._deviceAcronym,
                write: function (value) {
                    if (value === self._deviceAcronym())
                        return;

                    if (value) {
                        value = value.trim();
                        self._deviceAcronym(value);
                    }
                    else {
                        self.deviceAcronym(value);
                    }
                },
                owner: self
            });

            self.instanceName = ko.pureComputed({
                read: self._instanceName,
                write: function (value) {
                    if (value === self._instanceName())
                        return;

                    if (value) {
                        self._instanceName(value);
                        Cookies.set("instanceName", value.toString(), { expires: 365 });
                    } else {
                        self._instanceName("");
                    }

                    if (self.dataHubIsConnected()) {
                        dataHub.queryHistorian(self.instanceName()).done(function (historian) {
                            self._historianID(historian.ID);
                        });
                    }
                },
                owner: self
            });

            self.templateType = ko.pureComputed({
                read: self._templateType,
                write: function (value) {
                    if (value === self._templateType())
                        return;

                    if (value) {
                        self._templateType(value);
                        Cookies.set("templateType", value.toString(), { expires: 365 });
                    } else {
                        self._templateType("");
                    }
                },
                owner: self
            });

            self.historianID = ko.pureComputed({
                read: self._historianID,
                owner: self
            });

            self.dataHubIsConnected = ko.pureComputed({
                read: self._dataHubIsConnected,
                write: function (value) {
                    if (value === undefined)
                        value = false;

                    self._dataHubIsConnected(value);

                    if (value)
                        self.refreshValidationErrors();
                },
                owner: self
            });

            self.isDirty = ko.pureComputed({
                read: self._isDirty,
                write: function (value) {
                    if (value === undefined)
                        value = true;

                    self._isDirty(value);
                },
                owner: self
            });

            // Methods

            self.updateConfigFrameDetails = function () {
                var voltageCount = 0;
                var currentCount = 0;
                var analogCount = 0;
                var digitalCount = 0;

                const cells = self.configFrame().Cells;
                const cellCount = cells.length;

                for (let i = 0; i < cellCount; i++) {
                    const cell = cells[i];

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                            voltageCount++;
                        else
                            currentCount++;
                    }

                    analogCount += cell.AnalogDefinitions.length;
                    digitalCount += cell.DigitalDefinitions.length;
                }

                self.configFrameDetails(String.format("Device Count {0} &ndash; {1} Voltage Phasors, {2} Current Phasors, {3} Analogs, {4} Digitals",
                    cellCount,
                    voltageCount,
                    currentCount,
                    analogCount,
                    digitalCount));

                self.addAnalogs(analogCount > 0);
                self.addDigitals(digitalCount > 0);
            }

            self.loadConfigFrame = function (configFrame) {
                self.configFrame(configFrame);
                self.voltageCount = 0;

                const deviceCount = self.configFrame().Cells.length;

                for (let i = 0; i < deviceCount; i++) {
                    const cell = self.configFrame().Cells[i];

                    let cellAcronym = cell.IDLabel;

                    if (isEmpty(cellAcronym))
                        cellAcronym = cell.StationName.toUpperCase().replaceAll(" ", "_");

                    if (deviceCount === 1) {
                        self.deviceAcronym(cellAcronym);
                        cell.IDLabel = self.deviceAcronym;
                    } else {
                        cell.IDLabel = ko.observable(cellAcronym);
                    }

                    cell.IDLabel.extend({
                        required: true,
                        pattern: {
                            message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                            params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                        },
                        deviceUniqueInDatabase: true
                    });

                    for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                        const phasorDefinition = cell.PhasorDefinitions[j];

                        phasorDefinition.Label = String(phasorDefinition.Label).toUpperCase();

                        if (phasorDefinition.PhasorType.toLowerCase() === "voltage")
                            self.voltages.push(self.createObservableVoltage(cell.IDLabel, phasorDefinition));
                        else
                            self.currents.push(self.createObservableCurrent(cell.IDLabel, phasorDefinition));
                    }
                }

                // Make sure table is refreshed
                if (ko.options.deferUpdates)
                    ko.tasks.runEarly();

                self.errors = ko.validation.group([
                    self.deviceAcronym,
                    self.voltages,
                    self.currents
                ]);

                self.refreshValidationErrors();

                $("[id=voltageRow]").css("visibility", "visible");
                $("[id=currentRow]").css("visibility", "visible");
                hideLoadingLabel();

                self.updateConfigFrameDetails();

                self.isDirty(false);

                if (deviceCount === 1)
                    $(".device-singleton").hide();
                else
                    $(".device-singleton").show();
            }

            self.loadExisting = function () {
                if (!self.dataHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                dataHub.extractConfigurationFrame(deviceID).done(self.loadConfigFrame).fail(function (error) {
                    showErrorMessage(String.format("Failed to extract config file from existing device: {0}", error));

                    self.configFrameDetails("Unavailable");
                    $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            }

            self.analyzeConfig = function (sourceData) {
                if (!self.dataHubIsConnected())
                    return;

                self.voltages.removeAll();
                self.currents.removeAll();

                $("#responsiveTableDiv").show();
                $("[id=voltageRow]").css("visibility", "hidden");
                $("[id=currentRow]").css("visibility", "hidden");
                $("#bulkSelectionButtons").hide();
                showLoadingLabel();

                self.configFrameDetails("Analyzing...");

                // If device is currently active, disconnect it before requesting a configuration
                // frame in case device doesn't support multiple connections
                if (deviceID > 0)
                    serviceHub.sendCommand("disconnect " + deviceID);

                dataHub.loadConfigurationFrame(sourceData).done(self.loadConfigFrame).then(function () {
                    // Reconnect device
                    if (deviceID > 0)
                        serviceHub.sendCommand("connect " + deviceID);
                })
                .fail(function (error) {
                    showErrorMessage(String.format("Failed to analyze config file: {0}", error));

                    self.configFrameDetails("Unavailable");
                    $("[id=voltageRow]").css("visibility", "visible");
                    $("[id=currentRow]").css("visibility", "visible");
                    hideLoadingLabel();
                });
            }

            self.refreshValidationErrors = function () {
                // Make sure any initial validation error messages are visible
                self.errors.showAllMessages();
            }

            self.createObservableVoltage = function (deviceLabel, phasorDefinition) {
                const voltage = {};
                const phasorLabel = phasorDefinition.Label;
                const nominalVoltage = guessNominalVoltage(phasorLabel, deviceLabel());
                const phase = guessPhase(phasorLabel);

                voltage.ID = self.voltageCount++;
                voltage.Device = deviceLabel;
                voltage.Label = ko.observable(phasorLabel);
                voltage.Phase = ko.observable(phase);
                voltage.NominalVoltage = ko.observable(nominalVoltage);

                voltage.Label.extend({ required: true });
                voltage.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, - or N",
                        params: "^[A-C0+\\-N]$"
                    }
                });
                voltage.NominalVoltage.extend({ required: true });

                phasorDefinition.Voltage = voltage;
                phasorDefinition.Label = voltage.Label;
                phasorDefinition.Phase = voltage.Phase;

                return voltage;
            }

            self.createObservableCurrent = function (deviceLabel, phasorDefinition) {
                const current = {};
                const phasorLabel = phasorDefinition.Label;
                const phase = guessPhase(phasorLabel);
                const associatedVoltage = guessAssociatedVoltage(self.voltages(), phasorLabel, phase);

                current.Device = deviceLabel;
                current.Label = ko.observable(phasorLabel);
                current.Phase = ko.observable(phase);
                current.AssociatedVoltage = ko.observable(associatedVoltage);

                current.Label.extend({ required: true });
                current.Phase.extend({
                    required: true,
                    pattern: {
                        message: "Must be one of: A, B, C, 0, +, - or N",
                        params: "^[A-C0+\\-N]$"
                    }
                });

                phasorDefinition.Current = current;
                phasorDefinition.Label = current.Label;
                phasorDefinition.Phase = current.Phase;

                return current;
            }

            // Validations
            self.deviceAcronym.extend({
                required: true,
                pattern: {
                    message: "@Raw(AcronymValidationAttribute.DefaultErrorMessage)",
                    params: "@Raw(AcronymValidationAttribute.ValidationPattern.JavaScriptEncode())"
                },
                deviceUniqueInDatabase: true
            });

            self.validationErrors = ko.pureComputed(function () {
                return self.errors().length;
            }).extend({
                notify: "always"
            });
        }

        function getDeviceSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < deviceSignalTypes.length; i++) {
                const deviceSignalType = deviceSignalTypes[i];

                if (deviceSignalType.Acronym.toUpperCase() === acronym)
                    return deviceSignalType;
            }

            return null;
        }

        function getPhasorSignalType(acronym) {
            acronym = acronym.toUpperCase();

            for (let i = 0; i < phasorSignalTypes.length; i++) {
                const phasorSignalType = phasorSignalTypes[i];

                if (phasorSignalType.Acronym.toUpperCase() === acronym)
                    return phasorSignalType;
            }

            return null;
        }

        function savePhasorMeasurement(cell, signalType, phasorDefinition, index) {
            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), signalType.Suffix, index);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return dataHub.queryMeasurement(signalReference).then(function (measurement) {
                return dataHub.createPhasorPointTag(cell.IDLabel(), signalType.Acronym, phasorDefinition.Label(), phasorDefinition.Phase(), index).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1} {2} {3}", cell.IDLabel(), phasorDefinition.Label(), phasorDefinition.Phase(), signalType.Name);
                    measurement.PhasorSourceIndex = index;
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = true;

                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
            });
        }

        function saveDevicePhasors(cell) {
            // Get phasor signal types
            const iphmSignalType = getPhasorSignalType("IPHM");
            const iphaSignalType = getPhasorSignalType("IPHA");
            const vphmSignalType = getPhasorSignalType("VPHM");
            const vphaSignalType = getPhasorSignalType("VPHA");

            if (iphmSignalType == null || iphaSignalType == null || vphmSignalType == null || vphaSignalType == null) {
                showErrorMessage("Failed to find one or more phasor signal type records.");
                return $.Deferred().resolve().promise();
            }

            return dataHub.queryPhasorCountForDevice(cell.ID).then(function (count) {
                const promise = count > 0 ? dataHub.deletePhasorsForDevice(cell.ID) : $.Deferred().resolve().promise();

                return promise.then(function () {
                    const promises = [];

                    for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                        const index = i + 1;
                        const phasorDefinition = cell.PhasorDefinitions[i];
                        const isVoltage = phasorDefinition.PhasorType.toLowerCase() === "voltage";

                        promises.push(dataHub.newPhasor().then(function (phasor) {
                            phasor.DeviceID = cell.ID;
                            phasor.Label = phasorDefinition.Label();
                            phasor.Type = isVoltage ? "V" : "I";
                            phasor.Phase = phasorDefinition.Phase();
                            phasor.SourceIndex = index;

                            return dataHub.addNewPhasor(phasor).then(function () {
                                if (isVoltage) {
                                    return savePhasorMeasurement(cell, vphmSignalType, phasorDefinition, index).then(function () {
                                        return savePhasorMeasurement(cell, vphaSignalType, phasorDefinition, index);
                                    })
                                    .then(function () {
                                        const vphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphmSignalType.Suffix, index);

                                        return dataHub.queryMeasurement(vphmSignalReference).done(function (measurement) {
                                            phasorDefinition.vphmMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        const vphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), vphaSignalType.Suffix, index);

                                        return dataHub.queryMeasurement(vphaSignalReference).done(function (measurement) {
                                            phasorDefinition.vphaMeasurement = measurement;
                                        });
                                    });
                                } else {
                                    return savePhasorMeasurement(cell, iphmSignalType, phasorDefinition, index).then(function () {
                                        return savePhasorMeasurement(cell, iphaSignalType, phasorDefinition, index);
                                    })
                                    .then(function () {
                                        const iphmSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphmSignalType.Suffix, index);

                                        return dataHub.queryMeasurement(iphmSignalReference).done(function (measurement) {
                                            phasorDefinition.iphmMeasurement = measurement;
                                        });
                                    })
                                    .then(function () {
                                        const iphaSignalReference = String.format("{0}-{1}{2}", cell.IDLabel(), iphaSignalType.Suffix, index);

                                        return dataHub.queryMeasurement(iphaSignalReference).done(function (measurement) {
                                            phasorDefinition.iphaMeasurement = measurement;
                                        });
                                    });
                                }
                             })
                            .fail(function (error) {
                                showErrorMessage("Failed to save new phasor: " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to create new phasor: " + error);
                        }));
                    }

                    return $(promises).whenAll();
                })
                .fail(function (error) {
                    showErrorMessage("Failed to delete old phasors: " + error);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to query phasor count: " + error);
            });
        }

        function saveFixedMeasurement(cell, signalType, label) {
            const signalReference = String.format("{0}-{1}", cell.IDLabel(), signalType.Suffix);

            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
            return dataHub.queryMeasurement(signalReference).then(function (measurement) {
                return dataHub.createPointTag(cell.IDLabel(), signalType.Acronym).then(function (pointTag) {
                    measurement.DeviceID = cell.ID;
                    measurement.HistorianID = viewModel.historianID();
                    measurement.PointTag = pointTag;
                    measurement.Description = String.format("{0} {1}", cell.IDLabel(), signalType.Name, isEmpty(label) ? "" : " - " + label);
                    measurement.SignalReference = signalReference;
                    measurement.SignalTypeID = signalType.ID;
                    measurement.Internal = true;
                    measurement.Enabled = true;

                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                    });
                })
                .fail(function (error) {
                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                });
            })
            .fail(function (error) {
                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
            });
        }

        function saveDeviceMeasurements(cell) {
            const freqSignalType = getDeviceSignalType("FREQ");
            const dfdtSignalType = getDeviceSignalType("DFDT");
            const flagSignalType = getDeviceSignalType("FLAG");

            if (freqSignalType == null || dfdtSignalType == null || flagSignalType == null) {
                showErrorMessage("Failed to find one or more signal type records.");
                return $.Deferred().resolve().promise();
            }

            // Add frequency
            return saveFixedMeasurement(cell, freqSignalType, cell.FrequencyDefinition.Label).then(function () {
                // Add dF/dt
                return saveFixedMeasurement(cell, dfdtSignalType);
            })
            .then(function () {
                // Add status flags
                return saveFixedMeasurement(cell, flagSignalType);
            })
            .then(function () {
                // Add analogs
                if (viewModel.addAnalogs()) {
                    const analogSignalType = getDeviceSignalType("ALOG");

                    if (analogSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.AnalogDefinitions.length; i++) {
                            const index = i + 1;
                            const analogDefinition = cell.AnalogDefinitions[i];
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), analogSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(dataHub.queryMeasurement(signalReference).then(function (measurement) {
                                return dataHub.createIndexedPointTag(cell.IDLabel(), analogSignalType.Acronym, index).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = analogDefinition.Label;
                                    measurement.Description = String.format("{0} Analog Value {1}:{2}: {3}", cell.IDLabel(), index, analogDefinition.AnalogType, analogDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = analogSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find analog signal type record.");
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                // Add digitals
                if (viewModel.addDigitals()) {
                    const digitalSignalType = getDeviceSignalType("DIGI");

                    if (digitalSignalType != null) {
                        const promises = [];

                        for (let i = 0; i < cell.DigitalDefinitions.length; i++) {
                            const index = i + 1;
                            const digitialDefinition = cell.DigitalDefinitions[i];
                            const signalReference = String.format("{0}-{1}{2}", cell.IDLabel(), digitalSignalType.Suffix, index);

                            // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                            promises.push(dataHub.queryMeasurement(signalReference).then(function (measurement) {
                                return dataHub.createIndexedPointTag(cell.IDLabel(), digitalSignalType.Acronym, index).then(function (pointTag) {
                                    measurement.DeviceID = cell.ID;
                                    measurement.HistorianID = viewModel.historianID();
                                    measurement.PointTag = pointTag;
                                    measurement.AlternateTag = digitialDefinition.Label;
                                    measurement.Description = String.format("{0} Digital Value {1}: {2}", cell.IDLabel(), index, digitialDefinition.Label);
                                    measurement.SignalReference = signalReference;
                                    measurement.SignalTypeID = digitalSignalType.ID;
                                    measurement.Internal = true;
                                    measurement.Enabled = true;

                                    return dataHub.addNewOrUpdateMeasurement(measurement).fail(function (error) {
                                        showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                            }));
                        }

                        return $(promises).whenAll();
                    }
                    else {
                        showErrorMessage("Failed to find digital signal type record.");
                        return $.Deferred().resolve().promise();
                    }
                }
                else {
                    return $.Deferred().resolve().promise();
                }
            })
            .then(function () {
                return saveDevicePhasors(cell);
            });
        }

        function lookupAssociatedVoltage(cell, voltageID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage" && phasorDefinition.Voltage.ID === voltageID)
                    return phasorDefinition;
            }

            return null;
        }

        function savePowerCalcuations(cell, tagTemplate, powerCalculations) {
            const promises = [];
            const phase = tagTemplate.Inputs[0].toUpperCase()[0];

            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                // Power calculations can be applied to currents with an associated voltage
                if (phasorDefinition.PhasorType.toLowerCase() === "current" &&
                    phasorDefinition.Phase().toUpperCase() === phase &&
                    phasorDefinition.Current.AssociatedVoltage() > -1) {
                    const current = phasorDefinition;
                    const voltage = lookupAssociatedVoltage(cell, phasorDefinition.Current.AssociatedVoltage());

                    if (voltage) {
                        const vphmID = voltage.vphmMeasurement.SignalID;
                        const vphaID = voltage.vphaMeasurement.SignalID;
                        const iphmID = current.iphmMeasurement.SignalID;
                        const iphaID = current.iphaMeasurement.SignalID;

                        promises.push(dataHub.newPowerCalculation().then(function (powerCalculation) {
                            powerCalculation.CircuitDescription = String.format("{0}-{1}-{2}", cell.IDLabel(), tagTemplate.TagName, current.Label());
                            powerCalculation.VoltageMagSignalID = vphmID;
                            powerCalculation.VoltageAngleSignalID = vphaID;
                            powerCalculation.CurrentMagSignalID = iphmID;
                            powerCalculation.CurrentAngleSignalID = iphaID;
                            powerCalculation.Enabled = true;

                            return dataHub.addNewPowerCalculation(powerCalculation).done(function () {
                                powerCalculations.push([vphmID, vphaID, iphmID, iphaID]);
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to add new power calculation record: " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to create new power calculation record: " + error);
                        }));
                    }
                }
            }

            return $(promises).whenAll().done(function () {
                serviceHub.sendCommand("initialize PHASOR!POWERCALC");
            });
        }

        function saveSumPhase(cell, tagTemplate, powerCalculations) {
            const type = tagTemplate.Inputs[0]; // MW, MVAR, MVA

            return $.Deferred().resolve().promise();
        }

        var dynamicCalculation = {
            initialized: false,
            deviceVariables: new Dictionary(),
            FAVG: "",
            FNOM: 60
        };

        function initializeDynamicCalculation() {
            if (dynamicCalculation.initialized)
                return $.Deferred().resolve().promise();

            // Input variables - expanded per device:
            //   VNOM: Nominal Voltage = viewModel.configFrame().PhasorDefintions[voltage].Voltage.NominalFrequency
            //    VAM: Voltage A-Phase Magnitude    also VBM, VCM, VNM for B, C & N phases and VPOSM, VNEGM, VZM for +, -, 0 sequence
            //    VAA: Voltage A-Phase Angle        also VBA, VCA, VNA            ↑            VPOSA, VNEGA, VZA
            //    IAM: Current A-Phase Magnitude    also IBM, ICM, INM         Neutral         IPOSM, INEGM, IZM
            //    IAA: Current A-Phase Angle        also IBA, ICA, INA                         IPOSA, INEGA, IZA
            //   FREQ: Frequency
            //  FLAGS: Status Flags
            //   TIME: Timestamp
            //   FAVG: Frequency Average = system singleton where signal reference = "SYSTEM!FREQ-AVG-FQ"

            const promises = [];
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            for (let i = 0; i < cellCount; i++) {
                const cell = cells[i];
                const label = cell.IDLabel();
                const vars = {
                      VAM: [],   VBM: [],   VCM: [],   VNM: [],   VPOSM: [],   VNEGM: [],   VZM: [],
                      VAA: [],   VBA: [],   VCA: [],   VNA: [],   VPOSA: [],   VNEGA: [],   VZA: [],
                    VANOM: [], VBNOM: [], VCNOM: [], VNNOM: [], VPOSNOM: [], VNEGNOM: [], VZNOM: [],
                      IAM: [],   IBM: [],   ICM: [],   INM: [],   IPOSM: [],   INEGM: [],   IZM: [],
                      IAA: [],   IBA: [],   ICA: [],   INA: [],   IPOSA: [],   INEGA: [],   IZA: [],
                     FREQ: "", FLAGS: "",  TIME: 0
                };

                for (let j = 0; j < cell.PhasorDefinitions.length; j++) {
                    const phasorDefinition = cell.PhasorDefinitions[j];
                    const phase = phasorDefinition.Phase().toUpperCase();

                    if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                        const nominalVoltage = phasorDefinition.Voltage.NominalVoltage();
                        const nominalVoltage3 = nominalVoltage / 1.7320508075688772;

                        switch (phase) {
                            case "A":
                                vars.VAM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VAA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VANOM.push(nominalVoltage3);
                                break;
                            case "B":
                                vars.VBM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VBA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VBNOM.push(nominalVoltage3);
                                break;
                            case "C":
                                vars.VCM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VCA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VCNOM.push(nominalVoltage3);
                                break;
                            case "N": // Neutral
                                vars.VNM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNNOM.push(nominalVoltage);
                                break;
                            case "+": // Positive Sequence
                                vars.VPOSM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VPOSA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VPOSNOM.push(nominalVoltage);
                                break;
                            case "-": // Negative Sequence
                                vars.VNEGM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VNEGA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VNEGNOM.push(nominalVoltage);
                                break;
                            case "0": // Zero Sequence
                                vars.VZM.push(phasorDefinition.vphmMeasurement.SignalID);
                                vars.VZA.push(phasorDefinition.vphaMeasurement.SignalID);
                                vars.VZNOM.push(nominalVoltage);
                                break;
                            default:
                                continue;
                        }
                    } else {
                        switch (phase) {
                            case "A":
                                vars.IAM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IAA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "B":
                                vars.IBM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IBA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "C":
                                vars.ICM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.ICA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "N": // Neutral
                                vars.INM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "+": // Positive Sequence
                                vars.IPOSM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IPOSA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "-": // Negative Sequence
                                vars.INEGM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.INEGA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            case "0": // Zero Sequence
                                vars.IZM.push(phasorDefinition.iphmMeasurement.SignalID);
                                vars.IZA.push(phasorDefinition.iphaMeasurement.SignalID);
                                break;
                            default:
                                continue;
                        }
                    }
                }

                promises.push(dataHub.queryMeasurement(label + "-FQ").then(function (measurement) {
                    vars.FREQ = measurement.SignalID;
                    return dataHub.queryMeasurement(label + "-SF");
                })
                .then(function (measurement) {
                    vars.FLAGS = measurement.SignalID;
                    dynamicCalculation.deviceVariables.set(label, vars);
                })
                .fail(function (error) {
                    showErrorMessage("Failed to find device '" + label + "' frequency or flags: " + error);
                }));
            }

            return $(promises).whenAll().then(function () {
                return dataHub.queryMeasurement("SYSTEM!FREQ-AVG-FQ");
            })
            .then(function (measurement) {
                if (measurement && measurement.SignalID)
                    dynamicCalculation.FAVG = measurement.SignalID;

                dynamicCalculation.FNOM = @Program.Host.Model.Global.NominalFrequency;
                dynamicCalculation.initialized = true;
            })
            .fail(function (error) {
                showErrorMessage("Failed to find average system frequency 'SYSTEM!FREQ-AVG-FQ': " + error);
            });
        }

        function lookupAssociatedPhasorDefinition(cell, signalID) {
            for (let i = 0; i < cell.PhasorDefinitions.length; i++) {
                const phasorDefinition = cell.PhasorDefinitions[i];

                if (phasorDefinition.PhasorType.toLowerCase() === "voltage") {
                    if (phasorDefinition.vphmMeasurement.SignalID === signalID || phasorDefinition.vphaMeasurement.SignalID === signalID)
                        return phasorDefinition;
                }
                else {
                    if (phasorDefinition.iphmMeasurement.SignalID === signalID || phasorDefinition.iphaMeasurement.SignalID === signalID)
                        return phasorDefinition;
                }
            }

            return null;
        }

        function saveDynamicCalculation(cell, tagTemplate) {
            return initializeDynamicCalculation().then(function () {
                const vars = dynamicCalculation.deviceVariables.get(cell.IDLabel());
                var inputSet = {};

                for (let i = 0; i < tagTemplate.Inputs.length; i++) {
                    let templateName = tagTemplate.Inputs[i].toUpperCase();
                    let varName = templateName;

                    if (templateName === "FNOM") {
                        inputSet.FNON = dynamicCalculation.FNOM;
                        continue;
                    }

                    if (templateName === "FAVG") {
                        inputSet.FAVG = dynamicCalculation.FAVG;
                        continue;
                    }

                    // Map VNOM since it's entered as per-phasor nominal voltage
                    if (templateName === "VNOM") {
                        for (let j = 0; j < tagTemplate.Inputs.length; j++) {
                            if (i === j)
                                continue;

                            switch (tagTemplate.Inputs[j].toUpperCase()) {
                                case "VAM":
                                case "VAA":
                                    varName = "VANOM";
                                    break;
                                case "VBM":
                                case "VBA":
                                    varName = "VBNOM";
                                    break;
                                case "VCM":
                                case "VCA":
                                    varName = "VCNOM";
                                    break;
                                case "VNM":
                                case "VNA":
                                    varName = "VNNOM";
                                    break;
                                case "VPOSM":
                                case "VPOSA":
                                    varName = "VPOSNOM";
                                    break;
                                case "VNEGM":
                                case "VNEGA":
                                    varName = "VNEGNOM";
                                    break;
                                case "VZM":
                                case "VZA":
                                    varName = "VZNOM";
                                    break;
                            }

                            if (varName !== templateName)
                                break;
                        }

                        if (varName === "VNOM")
                            varName = "VANOM";
                    }

                    inputSet[templateName] = vars[varName];
                }

                var maxChannelCount = 0;
                var inputsAvailable = true;

                // Get max channel count
                for (let property in inputSet) {
                    if (inputSet.hasOwnProperty(property)) {
                        // Ignore non-array elements
                        if (!Array.isArray(inputSet[property]))
                            continue;

                        const channelCount = inputSet[property].length;

                        if (channelCount > maxChannelCount)
                            maxChannelCount = channelCount;
                    }
                }

                // Validate inputs
                if (maxChannelCount > 0) {
                    for (let property in inputSet) {
                        if (inputSet.hasOwnProperty(property)) {
                            // Ignore non-array elements
                            if (!Array.isArray(inputSet[property]))
                                continue;

                            if (maxChannelCount !== inputSet[property].length) {
                                inputsAvailable = false;
                                break;
                            }
                        }
                    }

                } else {
                    inputsAvailable = false;
                }

                const promises = [];
                const analogSignalType = getDeviceSignalType("ALOG");

                if (inputsAvailable && analogSignalType != null) {
                    for (let i = 0; i < maxChannelCount; i++) {
                        const index = i;
                        const signalReference = String.format("{0}-{1}-{2}{3}", cell.IDLabel(), tagTemplate.TagName, analogSignalType.Suffix, index);

                        // Query existing measurement record for specified signal reference - function will create a new blank measurement record if one does not exist
                        promises.push(dataHub.queryMeasurement(signalReference).then(function (measurement) {
                            return dataHub.createPointTag(cell.IDLabel(), analogSignalType.Acronym).then(function (pointTag) {
                                measurement.DeviceID = cell.ID;
                                measurement.HistorianID = viewModel.historianID();
                                measurement.PointTag = String.format("{0}-{1}-<0>", cell.IDLabel(), tagTemplate.TagName, analogSignalType.Suffix, index);
                                measurement.Description = String.format("{0} <0> Analog Value {1}: {2}", cell.IDLabel(), index, tagTemplate.Description);
                                measurement.SignalReference = signalReference;
                                measurement.SignalTypeID = analogSignalType.ID;
                                measurement.Internal = true;
                                measurement.Enabled = true;

                                return dataHub.addNewOrUpdateMeasurement(measurement).then(function () {
                                    return dataHub.queryMeasurement(signalReference).then(function (measurement) {
                                        var phasorDefinition = null;
                                        const connectionString = new Dictionary();
                                        const variableList = new Dictionary();
                                        var equation = tagTemplate.Equation;

                                        for (let property in inputSet) {
                                            if (inputSet.hasOwnProperty(property)) {
                                                if (Array.isArray(inputSet[property])) {
                                                    if (property === "VNOM") {
                                                        // Replace VNOM constant
                                                        equation = equation.replaceAll("VNOM", String(inputSet.VNOM[index]), true);
                                                    }
                                                    else {
                                                        // Assign variable to signal ID
                                                        const signalID = inputSet[property][index] + "";
                                                        variableList.set(property, signalID);

                                                        if (phasorDefinition == null) {
                                                            const matchedPhasorDefinition = lookupAssociatedPhasorDefinition(cell, signalID);

                                                            if (matchedPhasorDefinition != null)
                                                                phasorDefinition = matchedPhasorDefinition;
                                                        }
                                                    }
                                                }
                                                else {
                                                    if (property === "FNOM") {
                                                        // Replace FNOM constant
                                                        equation = equation.replaceAll("FNOM", String(inputSet.FNOM), true);
                                                    } else if (property === "TIME") {
                                                        // TODO: Properly handle time
                                                        equation = equation.replaceAll("TIME", "0", true);
                                                    } else {
                                                        // Assign variable to signal ID
                                                        const signalID = inputSet[property] + "";
                                                        variableList.set(property, signalID);
                                                    }
                                                }
                                            }
                                        }

                                        // Inject phasor definition label into output measurement point tag and description
                                        if (phasorDefinition != null) {
                                            const label = phasorDefinition.Label().replaceAll(" ", "_").toUpperCase();
                                            measurement.PointTag = String.format(measurement.PointTag.replace("<0>", "{0}"), label);
                                            measurement.Description = String.format(measurement.Description.replace("<0>", "{0}"), phasorDefinition.Label());
                                            dataHub.updateMeasurement(measurement);
                                        }
                                        else {
                                            measurement.PointTag = measurement.PointTag.replace("-<0>", "");
                                            measurement.Description = measurement.Description.replace(" <0>", "");
                                            dataHub.updateMeasurement(measurement);
                                        }

                                        connectionString.set("variableList", variableList.joinKeyValuePairs());
                                        connectionString.set("expressionText", equation);
                                        connectionString.set("framesPerSecond", viewModel.configFrame().FrameRate);
                                        connectionString.set("lagTime", "5.0");
                                        connectionString.set("leadTime", "3.0");
                                        connectionString.set("outputMeasurements", measurement.SignalID);

                                        return dataHub.newCustomActionAdapter().then(function (adapter) {
                                            adapter.NodeID = nodeID;
                                            adapter.AdapterName = measurement.PointTag;
                                            adapter.AssemblyName = "DynamicCalculator.dll";
                                            adapter.TypeName = "DynamicCalculator.DynamicCalculator";
                                            adapter.ConnectionString = connectionString.joinKeyValuePairs();
                                            adapter.LoadOrder = 100;
                                            adapter.Enabled = true;

                                            return dataHub.addNewCustomActionAdapter(adapter).then(function () {
                                                return serviceHub.sendCommand("initialize " + adapter.AdapterName);
                                            })
                                            .fail(function (error) {
                                                showErrorMessage("Save failed for new custom action measurement: " + error);
                                            });
                                        })
                                        .fail(function (error) {
                                            showErrorMessage("Failed to create new custom action adapter record: " + error);
                                        });                                        
                                    })
                                    .fail(function (error) {
                                        showErrorMessage("Failed to lookup measurement " + signalReference + ": " + error);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Save failed for new measurement " + signalReference + ": " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Failed to create point tag for measurement " + signalReference + ": " + error);
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed to lookup or create measurement " + signalReference + ": " + error);
                        }));
                    }
                }

                return $(promises).whenAll();
            });
        }

        function saveTemplateCalculations(cell) {
            const templateType = viewModel.templateType();

            if (templateType.toUpperCase() === "NONE")
                return $.Deferred().resolve().promise();

            return dataHub.loadTemplate(templateType).then(function (tagTemplates) {
                const promises = [];
                const powerCalculations = [];

                for (let i = 0; i < tagTemplates.length; i++) {
                    const tagTemplate = tagTemplates[i];

                    switch (tagTemplate.Type.toUpperCase()) {
                        case "CALCULATEPOWER":
                            promises.push(savePowerCalcuations(cell, tagTemplate, powerCalculations));
                            break;
                        case "SUMPHASE":
                            promises.push(saveSumPhase(cell, tagTemplate, powerCalculations));
                            break;
                        case "DYNAMICCALCULATOR":
                            promises.push(saveDynamicCalculation(cell, tagTemplate));
                            break;
                    }
                }

                return $(promises).whenAll();
            })
            .fail(function (error) {
                showErrorMessage("Failed to load " + templateType + " tag template: " + error);
            });
        }

        function saveDeviceRecords(id) {
            const configFrame = viewModel.configFrame();
            const cells = configFrame.Cells;
            const cellCount = cells.length;

            if (cellCount === 1) {
                // Direct connected device - save associated records
                const cell = cells[0];
                cell.ID = id;

                return saveDeviceMeasurements(cell).then(function () {
                    return saveTemplateCalculations(cell);
                });
            }
            else {
                const promises = [];

                // PDC connected device - save children devices
                for (let i = 0; i < cellCount; i++) {
                    const cell = cells[i];

                    // Query existing child device record for specified acronym - function will create a new blank device record if one does not exist
                    promises.push(dataHub.queryDevice(cell.IDLabel()).then(function (device) {
                        // Set child device properties
                        device.ParentID = id;
                        device.HistorianID = viewModel.historianID();
                        device.ProtocolID = configFrame.ProtocolID;
                        device.FrameRate = configFrame.FrameRate;
                        device.AccessID = cell.IDCode;
                        device.Acronym = cell.IDLabel();
                        device.Name = device.Acronym;
                        device.Enabled = true;

                        // Check if this is a new device or an edit to an existing one
                        if (device.ID === 0) {
                            // Add new device record
                            return dataHub.addNewDevice(device).then(function () {
                                // Get newly added device with auto-incremented ID
                                return dataHub.queryDevice(device.Acronym).then(function (newDevice) {
                                    // Save associated device records...
                                    cell.ID = newDevice.ID;

                                    return saveDeviceMeasurements(cell).then(function () {
                                        return saveTemplateCalculations(cell);
                                    });
                                })
                                .fail(function (error) {
                                    showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Save failed for new device " + device.Acronym + ": " + error);
                            });
                        }
                        else {
                            // Update existing device record
                            return dataHub.updateDevice(device).then(function () {
                                // Save associated device records...
                                cell.ID = device.ID;
                                
                                return saveDeviceMeasurements(cell).then(function () {
                                    return saveTemplateCalculations(cell);
                                });
                            })
                            .fail(function (error) {
                                showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error);
                            });
                        }
                    })
                    .fail(function (error) {
                        showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error);
                    }));
                }

                return $(promises).whenAll();
            }
        }

        function saveDeviceConnection() {
            if (!viewModel.editMode() && isEmpty(viewModel.configFrame().ConnectionString)) {
                showErrorMessage("Cannot save device connection without a connection string");
                return $.Deferred().resolve().promise();
            }

            if (!hubIsConnected) {
                showErrorMessage("Cannot save device connection, cannot connect to server.");
                return $.Deferred().resolve().promise();
            }

            showInfoMessage("Saving device connection, please wait...", -1);
            disableUIButtons();

            // Query existing device record for specified acronym - function will create a new blank device record if one does not exist
            return dataHub.queryDevice(viewModel.deviceAcronym()).then(function (device) {
                // Set device properties
                const configFrame = viewModel.configFrame();
                var connectionString = configFrame.ConnectionString + "";
                const connectionStringMap = new Dictionary(connectionString.parseKeyValuePairs());
                var autoStartDataParsingSequence = true;
                var skipDisableRealTimeData = false;

                // Handle connection string parameters that are fields in the device table
                if (connectionStringMap.containsKey("autoStartDataParsingSequence")) {
                    autoStartDataParsingSequence = connectionStringMap.get("autoStartDataParsingSequence");
                    connectionStringMap.remove("autoStartDataParsingSequence");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                if (connectionStringMap.containsKey("skipDisableRealTimeData")) {
                    skipDisableRealTimeData = connectionStringMap.get("skipDisableRealTimeData");
                    connectionStringMap.remove("skipDisableRealTimeData");
                    connectionString = connectionStringMap.joinKeyValuePairs();
                }

                device.Acronym = viewModel.deviceAcronym();
                device.HistorianID = viewModel.historianID();
                device.ProtocolID = configFrame.ProtocolID;
                device.FrameRate = configFrame.FrameRate;
                device.AccessID = configFrame.IDCode;
                device.Name = device.Acronym;
                device.ConnectionString = connectionString;
                device.AutoStartDataParsingSequence = autoStartDataParsingSequence;
                device.SkipDisableRealTimeData = skipDisableRealTimeData;
                //device.Longitude = viewModel.longitude();
                //device.Latitude = viewModel.latitude();
                device.Enabled = true;

                // Check if this is a new device or an edit to an existing one
                if (device.ID === 0) {
                    // Add new device record
                    return dataHub.addNewDevice(device).then(function () {
                        // Get newly added device with auto-incremented ID
                        return dataHub.queryDevice(device.Acronym).then(function (newDevice) {
                            // Save associated device records...
                            deviceID = newDevice.ID;

                            return saveDeviceRecords(deviceID).then(function () {
                                enableUIButtons("Save complete.");

                                serviceHub.sendCommand("initialize " + deviceID).done(function () {
                                    window.location = "GraphMeasurements.cshtml";
                                });
                            });
                        })
                        .fail(function (error) {
                            showErrorMessage("Failed while querying new device " + device.Acronym + " - no measurements saved: " + error);
                            enableUIButtons();
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Save failed for new device " + device.Acronym + ": " + error);
                        enableUIButtons();
                    });
                }
                else {
                    // Update existing device record
                    return dataHub.updateDevice(device).then(function () {
                        // Save associated device records...
                        return saveDeviceRecords(device.ID).then(function () {
                            enableUIButtons("Save complete.");

                            const connectionID = device.ParentID ? device.ParentID : device.ID;

                            serviceHub.sendCommand("initialize " + connectionID).done(function () {
                                window.location = "GraphMeasurements.cshtml";
                            });
                        });
                    })
                    .fail(function (error) {
                        showErrorMessage("Update failed for existing device " + device.Acronym + " - no measurements updated: " + error);
                        enableUIButtons();
                    });
                }
            })
            .fail(function (error) {
                showErrorMessage("Save failed for new device " + device.Acronym + " - could not create new or lookup existing device: " + error);
                enableUIButtons();
            });
        }

        // Load existing device data
        function loadDeviceConnection(id) {
            if (!hubIsConnected)
                return;

            dataHub.queryDeviceByID(id).done(function (device) {
                $("#editDeviceName").html("Editing&nbsp;" + device.Acronym);
            })
            .fail(function (error) {
                showErrorMessage(String.format("Failed to load existing device \"{0}\": {1}", id, error));
            });
        }

        function resizePageElements() {
            if (deviceID === 0)
                $("#inputDeviceAcronym").width($("#inputConfigFile").width());

            $("#contentWell").height(calculateRemainingBodyHeight() - $("#headerArea").outerHeight(true));
        }

        function disableUIButtons() {
            $("#inputConfigFile").disable();
            $("#saveData").disable();
            showLoadingLabel();
        }

        function enableUIButtons(message) {
            $("#inputConfigFile").enable();
            $("#saveData").enable();
            hideLoadingLabel();

            if (message === undefined)
                hideInfoMessage();
            else
                showInfoMessage(message);
        }

        // Page initialization function
        $(function () {
            $("#bodyContainer").addClass("fill-height");

            // Define local rule that will check that device acronym is unique in the database
            ko.validation.rules["deviceUniqueInDatabase"] = {
                async: true,
                validator: function (newVal, options, callback) {
                    if (options && viewModel.dataHubIsConnected()) {
                        // Lookup Device record by Acronym - this will return an empty record if not found
                        dataHub.queryDevice(newVal).done(function (device) {
                            // Valid if device doesn't exist or is itself
                            callback(device.ID === 0 || device.ID === deviceID);
                        })
                        .fail(function (error) {
                            showErrorMessage(error);

                            // Do not display validation failure message for connection issues
                            callback(true);
                        });
                    }
                    else {
                        callback(true);
                    }
                },
                message: "This device acronym already exists in the database. Acronyms must be unique."
            };

            ko.bindingHandlers.selectOnError = {
                init: function (element, valueAccessor) {
                    $(element).on("input", function(event) {
                        setTimeout(function () {
                            if (!valueAccessor().isValid())
                                element.select();
                        }, 1);
                    });
                }
            }

            // Enable knockout validation
            ko.validation.init({
                registerExtenders: true,
                messagesOnModified: true,
                insertMessages: true,
                parseInputAttributes: true,
                allowHtmlMessages: true,
                messageTemplate: null,
                decorateElement: true,
                errorElementClass: "has-error",
                errorMessageClass: "help-block",
                grouping: { deep: true, observable: true, live: true }
            }, true);

            // Enable deferred updates for better performance
            ko.options.deferUpdates = true;

            // Create the primary view model
            viewModel = new DeviceViewModel();

            // Initialize primary view model
            ko.applyBindings(viewModel);

            // Monitor for view model changes
            ko.watch(viewModel.devices, { depth: -1 }, function (parents, child, item) {
                viewModel.isDirty(true);
            });

            // Let view model know about hub connectivity changes
            $(window).on("hubConnected", function () {
                viewModel.dataHubIsConnected(true);

                if (!firstConnect)
                    return;

                firstConnect = false;

                if (deviceID > 0)
                    loadDeviceConnection(deviceID);

                const instanceNameSelect = $("#instanceName");

                // Load available historian instance names, if not already loaded
                if (instanceNameSelect.children("option").length === 0) {
                    dataHub.getInstanceNames().done(function (names) {
                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            instanceNameSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastInstanceName = Cookies.get("instanceName");

                        if (lastInstanceName === undefined)
                            lastInstanceName = instanceNameSelect.eq(0).val();

                        if (!isEmpty(lastInstanceName))
                            instanceNameSelect.val(lastInstanceName);

                        setTimeout(function () {
                            viewModel.instanceName(lastInstanceName);
                        }, 200);
                    });
                }

                const templateTypeSelect = $("#templateType");

                // Load available calculation templates, if not already loaded
                if (templateTypeSelect.children("option").length === 0) {
                    dataHub.getTemplateTypes().done(function (names) {
                        for (let i = 0; i < names.length; i++) {
                            const value = names[i];
                            templateTypeSelect.append($("<option>", { value: value, text: value }));
                        }

                        // Select last value
                        var lastTemplateType = Cookies.get("templateType");

                        if (lastTemplateType === undefined)
                            lastTemplateType = templateTypeSelect.eq(0).val();

                        if (!isEmpty(lastTemplateType))
                            instanceNameSelect.val(lastTemplateType);

                        setTimeout(function () {
                            viewModel.templateType(lastTemplateType);
                        }, 200);
                    });
                }

                dataHub.loadSignalTypes("PMU").then(function (result) {
                    deviceSignalTypes = result;

                    return dataHub.loadSignalTypes("Phasor").then(function (result) {
                        phasorSignalTypes = result;

                        if (deviceID > 0)
                            viewModel.loadExisting();
                    });
                });
            });

            $(window).on("hubDisconnected", function () {
                viewModel.dataHubIsConnected(false);
            });

            $(window).on("messageVisibiltyChanged", function () {
                resizePageElements();
            });

            $(window).resize(function () {
                resizePageElements();
            });

            // Define button handlers
            $("#saveData").click(function() {
                saveDeviceConnection();
            });

            $("#inputConfigFile").change(function(event){
                const uploadedFile = event.target.files[0];

                if (uploadedFile) {
                    const readFile = new FileReader();

                    readFile.onload = function(event) {
                        viewModel.analyzeConfig(event.target.result);
                    };

                    readFile.readAsText(uploadedFile);
                }

                $("#inputConfigFile").tooltip("hide");
            });

            resizePageElements();
            hideLoadingLabel();
        });
    </script>
}
<div id="headerArea">
    <h3 style="margin-top: -10px;">
        @ViewBag.Title <span class="label label-info" id="editDeviceName"></span> <!--img class="page-logo pull-right" src="Images/AddDevice.png" /-->
        <span style="padding-right: 10px" class="form-inline pull-right clearfix">
            <small>
                Instance:&nbsp;<select class="form-control" id="instanceName" data-bind="value: instanceName; valueAllowUnset: false" style="border: 0; width: 80px"></select>
            </small>
        </span>
    </h3>
    <form>
        <table style="width: 95%">
            <tr data-bind="visible: !editMode()">
                <td class="input-label">
                    <label for="inputConfigFile">Connection File:</label>
                </td>
                <td>
                    <div class="input-group input-area">
                        <input id="inputConfigFile" type="file" placeholder="Connection file name..." title="Select&nbsp;PMUConnection&nbsp;file..." accept=".PmuConnection,.xml,text/xml" data-toggle="tooltip" data-placement="right" class="form-control" style="width: 100%">
                    </div>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="inputDeviceAcronym"><span data-bind="text: configFrame().Cells.length == 1 ? 'Device' : 'Connection'">Connection</span> Acronym:</label>
                </td>
                <td>
                    <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(deviceAcronym, true), 'has-feedback': !fieldIsValid(deviceAcronym, true) }">
                        <input id="inputDeviceAcronym" type="text" class="form-control" style="width: 250px" data-bind="acronym: deviceAcronym, textInput: deviceAcronym" required>
                        <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(deviceAcronym, true)"></span>
                    </div>
                </td>
            </tr>
            <tr>
                <td class="input-label">
                    <label for="templateType">Tag Template:</label>
                </td>
                <td>
                    <div class="input-group">
                        <select class="form-control" id="templateType" data-bind="value: templateType; valueAllowUnset: false" style="border: 0; width: 110px"></select>
                        <div class="checkbox" style="display:inline; margin-left: 15px">
                            <label class="disabled" style="margin-top: 6px"><input type="checkbox" data-bind="checked: addTagsAsVirtualPoints" disabled> Generate virtual tags (otherwise tags will be archived)</label>
                        </div>
                    </div>
                </td>
            </tr>
        </table>
        <span class="pull-right clearfix" id="loadingDataLabel" style="display: inline; margin-top: -27px">
            Loading&nbsp;&nbsp;<span class="glyphicon glyphicon-refresh glyphicon-spin"></span>
        </span>
    </form>
</div>
<div id="contentWell" class="well well-dynamic-content">
    <div id="responsiveTableDiv" class="table-responsive" style="display: none; border: none">
        <span id="configFrameDetails">Config Frame: <span data-bind="html: configFrameDetails"></span></span>
        <span id="saveDataButton" class="pull-right" style="text-align: right">
            @if (userIsEditor)
            {
                <text>
                    <div class="input-group pull-right" style="margin-top: -4px">
                        <form class="form-inline" style="padding-bottom: 4px">
                            <div class="checkbox">
                                <label><input type="checkbox" data-bind="checked: addAnalogs"> Add Analogs</label>
                            </div>
                            <div class="checkbox" style="padding-left: 5px;">
                                <label><input type="checkbox" data-bind="checked: addDigitals"> Add Digitals</label>
                            </div>
                        </form>
                        <button type="button" class="btn btn-sm btn-primary pull-right" id="saveData" data-bind="disable: validationErrors() > 0 || !dataHubIsConnected() || (!editMode() && isEmpty(configFrame().ConnectionString))">
                            <span class="glyphicon glyphicon-plus"></span>&nbsp;&nbsp;Save&nbsp;Device
                        </button>
                    </div>
                </text>
            }
            else
            {
                <span class="label label-danger label-md">User "@GetCurrentUserID()" does not have rights to add or modify device data.</span>
            }
        </span>
        <span><br />Connection String: <span data-bind="text: configFrame().ConnectionString"></span></span>
        <em data-bind="visible: validationErrors() > 0">
            <br />
            <span data-bind="text: validationErrors()"></span> validation error<span data-bind="visible: validationErrors() > 1">s</span>...
        </em>
        <hr class="quarter-break" />
        <div id="configInfo"></div>
        
        <!-- Voltages Section -->
        <div class="col-md-6">
            <h3>Voltages</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                    <tr>
                        <th class="text-left device-singleton">Device&nbsp;Acronym</th>
                        <th class="text-left">Phasor&nbsp;Label</th>
                        <th class="text-center">Phase</th>
                        <th class="text-left">Nominal&nbsp;Voltage</th>
                    </tr>
                </thead>
                <tbody data-bind="foreach: { data: voltages }">
                    <tr id="voltageRow" style="visibility: hidden">
                        <td width="190px" class="text-left valign-middle device-singleton">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device, true), 'has-feedback': !fieldIsValid(Device, true) }">
                                <input \type="text" class="form-control" style="width: 180px" data-bind="acronym: Device, textInput: Device" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device, true)"></span>
                            </div>
                        </td>
                        <td width="210px" class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true) }">
                                <input type="text" class="form-control" style="width: 200px" data-bind="acronym: Label, textInput: Label" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                            </div>
                        </td>
                        <td width="55px" class="text-center valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true) }">
                                <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '70px' }, selectOnError: Phase" placeholder="Ø" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                            </div>
                        </td>
                        <td class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(NominalVoltage, true), 'has-feedback': !fieldIsValid(NominalVoltage, true) }">
                                <input type="text" class="form-control" style="width: 70px; margin-left: 10px" data-bind="integer: NominalVoltage, textInput: NominalVoltage" required>&nbsp;<span class="table-cell-text">kV</span>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(NominalVoltage, true)"></span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- Currents Section -->
        <div class="col-md-6">
            <h3>Currents</h3>
            <table class="table table-condensed table-striped table-hover">
                <thead>
                    <tr>
                        <th class="text-left device-singleton">Device&nbsp;Acronym</th>
                        <th class="text-left">Phasor&nbsp;Label</th>
                        <th class="text-center">Phase</th>
                        <th class="text-left">Associated&nbsp;Voltage</th>
                    </tr>
                </thead>
                <tbody data-bind="foreach: { data: currents }">
                    <tr id="currentRow" style="visibility: hidden">
                        <td width="190px" class="text-left valign-middle device-singleton">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Device, true), 'has-feedback': !fieldIsValid(Device, true) }">
                                <input \type="text" class="form-control" style="width: 180px" data-bind="acronym: Device, textInput: Device" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" data-bind="visible: !fieldIsValid(Device, true)"></span>
                            </div>
                        </td>
                        <td width="210px" class="text-left valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Label, true), 'has-feedback': !fieldIsValid(Label, true) }">
                                <input type="text" class="form-control" style="width: 200px" data-bind="acronym: Label, textInput: Label" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Label, true)"></span>
                            </div>
                        </td>
                        <td width="55px" class="text-center valign-middle">
                            <div class="input-group" data-bind="css: { 'has-error': !fieldIsValid(Phase, true), 'has-feedback': !fieldIsValid(Phase, true) }">
                                <input type="text" class="form-control" maxlength="1" style="width: 37px; margin-left: 3px" onclick="this.select()" data-bind="upperCase: Phase, textInput: Phase, style: { width: Phase.isValid() ? '37px' : '70px' }, selectOnError: Phase" placeholder="Ø" required>
                                <span class="glyphicon glyphicon-remove form-control-feedback" style="z-index: 5" data-bind="visible: !fieldIsValid(Phase, true)"></span>
                            </div>
                        </td>
                        <td class="text-left valign-middle">
                            <select class="form-control" style="width: 90%" data-bind="options: $parent.voltages, value: AssociatedVoltage, optionsText: 'Label', optionsValue: 'ID', valueAllowUnset: true"></select>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>