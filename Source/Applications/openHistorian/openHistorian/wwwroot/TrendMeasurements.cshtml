@*******************************************************************************************************
//  TrendMeasurements.cshtml - Gbtc
//
//  Copyright © 2016, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  07/30/2016 - Ritchie Carroll
//       Generated original version of source code.
//
//*****************************************************************************************************@
@using System.Text
@using GSF.Web.Model
@using openHistorian
@using openHistorian.Model
@inherits ExtendedTemplateBase<AppModel>
@section StyleSheets {
    <link href="Content/bootstrap-datetimepicker.min.css" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }

        .tabs-nohdr {
            padding: 0;
            background: none;
            border-width: 0;
        }
         
        .tabs-nohdr .ui-tabs-nav {
            padding: 0;
            background: transparent;
            border: none;
        }

        .tabs-nohdr .ui-tabs-panel {
            border: none;
            padding: 0;
            margin: 0;
        }

        /* Collapsable button style */
        .btn-collapsable.btn {
            color: #606060;
            font-family: "Glyphicons Halflings";
            font-size: 8pt;
            padding: 0 2px 2px 2px;
            height: 18px;
        }

        /* Collapsable button icon when content is shown - arrow down */
        .btn-collapsable.btn:after {
            content: "\e114";
        }

        /* Collapsable button icon when content is hidden - arrow right */
        .btn-collapsable.btn.collapsed:after {
            content: "\e080";
        }

        #collapseSelectedPoints.btn-collapsable.btn {
            margin-top: 3px;
            margin-left: -137px;
            -webkit-transition: all .75s ease-out;
            -moz-transition: all .75s ease-out;
            transition: all .75s ease-out;
        }

        #collapseSelectedPoints.btn-collapsable.btn.collapsed {
            margin-top: 7px;
            margin-left: -130px;
        }

        #collapseTrendSetup.btn-collapsable.btn {
            margin-top: 7px;
            margin-right: 6px;
            -webkit-transition: all .75s ease-out;
            -moz-transition: all .75s ease-out;
            transition: all .75s ease-out;
        }

        #collapseTrendSetup.btn-collapsable.btn.collapsed {
            margin-top: -24px;
        }

        span.fixed-font {
            font-size: small;
            font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;
        }

        span.input-group-addon i.disabled {
            color: #ccc;
            cursor: not-allowed;
        }

        hr.series-color {
            background-color: transparent;
            height: 5px;
            border: none;
            margin: 3px;
        }

        .axisLabels {
            -webkit-transform-origin: 50% 51%
        }

        .busy-state * {
            cursor: progress
        }

        #scrollablePointsArea {
            overflow: -moz-scrollbars-vertical; 
            overflow-y: scroll;
        }

        #selectAllProgress {
            position: absolute;
            margin-top: 6px;
            margin-left: 115px;
            font-size: smaller;
        }

        #selectAllProgressBar {
            padding-left: 10px;
            padding-bottom: 5px;
            padding-top: 2px;
        }

        #selectAllProgressCancel {
            font-size: small;
            padding-top: 1px;
            padding-bottom: 1px;
            margin-top: -20px;
            margin-left: 1px
        }

        #selectAllMessage {
            position: absolute;
            margin-top: 8px;
            margin-left: 15px;
            font-size: smaller;
        }

        #selectAllMessage a {
            color: #337ab7;
            text-decoration: none;
        }

        #selectAllMessage a:active, a:hover, a:focus {
            color: #23527c;
            text-decoration: underline;
            cursor: pointer;
        }

        #tabs ul li {
            outline: none;
        }

        #tabs ul li a {
            outline: none;
        }
    </style>
}
@{ 
    DataContext dataContext = ViewBag.DataContext;
    StringBuilder pageControlScripts = ViewBag.PageControlScripts;

    Layout = "Layout.cshtml";
    ViewBag.Title = "Trend/Export Measurements";
    ViewBag.AddNewEditTitle = "Measurement Detail";
    ViewBag.ShowSearchFilter = true;
    ViewBag.HideUnauthorizedControls = true;
    ViewBag.CanEdit = false;
    ViewBag.CanAddNew = false;
    ViewBag.CanDelete = false;

    ViewBag.HeaderColumns = new[]
    {   //    { "Field", "Label", "Classes" }
        new[] { null, "<input type='checkbox' id='selectAllCheckbox' title='Select All'/>", "text-center valign-middle" },
        new[] { "ID", "ID", "text-center" },
        new[] { "SignalType", "Type", "text-center" },
        new[] { "PointTag", "Tag&nbsp;Name", "text-left" },
        new[] { "SignalReference", "Signal&nbsp;Reference", "text-left" },
        new[] { "Description", "Description", "text-left" }
    };

    ViewBag.BodyRows = BodyRows().ToString();
    ViewBag.AddNewEditDialog = AddNewEditDialog(dataContext).ToString();
    ViewBag.PageRecordsForEachBinding = "afterRender: postRecordRendering";

    // Prepend view model extension scripts to occur before model initialization
    pageControlScripts.Insert(0, ExtendedViewModel(dataContext).ToString().TrimStart());
}
@helper BodyRows()
{
    <td width="5%" class="text-center valign-middle"><input type="checkbox" /></td>
    <td width="5%" class="text-center valign-middle"><span data-bind="text: PointID"></span></td>
    <td width="5%" class="text-center valign-middle"><span data-bind="text: SignalType"></span></td>
    <td width="15%" class="text-left valign-middle"><div data-bind="attr: { title: PointTag }"><button type="button" class="btn btn-link btn-sm" data-bind="text: PointTag.truncate(25), click: $parent.viewPageRecord"></button></div></td>
    <td width="15%" class="text-left valign-middle table-cell-hard-wrap"><div data-bind="text: $($element.parentElement).truncateToWidth(SignalReference, 2), attr: { title: SignalReference }"></div></td>
    <td width="50%" class="text-left table-cell-wrap"><div data-bind="text: $($element.parentElement).truncateToWidth(Description, 1.85), attr: { title: Description }"></div></td>
    <td width="5%" class="text-center valign-middle" nowrap>
        <button type="button" class="btn btn-xs" title="View Measurement Detail..." data-bind="click: $parent.viewPageRecord, enable: $parent.dataHubIsConnected"><span class="glyphicon glyphicon-list"></span></button>
    </td>
}
@helper AddNewEditDialog(DataContext dataContext)
{
    <div class="col-md-6">
        @Raw(dataContext.AddInputField<ActiveMeasurement>("ID", customDataBinding: "disable: true"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalID", customDataBinding: "disable: true"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Device"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("PointTag", initialFocus: true))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("AlternateTag"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalReference"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("SignalType"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("FramesPerSecond"))
    </div>
    <div class="col-md-6">
        @Raw(dataContext.AddTextAreaField<ActiveMeasurement>("Description", 4))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Protocol"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Adder"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Multiplier"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Company"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Longitude"))
        @Raw(dataContext.AddInputField<ActiveMeasurement>("Latitude"))
        <div class="form-inline pull-right">
            @Raw(dataContext.AddCheckBoxField<ActiveMeasurement>("Internal"))&nbsp;
            @Raw(dataContext.AddCheckBoxField<ActiveMeasurement>("Subscribed"))
        </div>
    </div>
}
@helper ExtendedViewModel(DataContext dataContext)
{
    <script src="Scripts/moment.min.js"></script>
    <script src="Scripts/bootstrap-datetimepicker.min.js"></script>
    <script src="Scripts/dateFormat.js"></script>
    <script>
        const MomentDateTimeFormat = dateFormat.convert(DateTimeFormat, dateFormat.dotnet, dateFormat.moment);

        var plot;

        // Data query resolutions enumeration
        var Resolution = {
            Full: 0,
            TenPerSecond: 1,
            EverySecond: 2,
            Every10Seconds: 3,
            Every30Seconds: 4,
            EveryMinute: 5,
            Every10Minutes: 6,
            Every30Minutes: 7,
            EveryHour: 8,
            EveryDay: 9,
            EveryMonth: 10
        }

        function estimatePlotResolution(startMoment, endMoment) {
            const span = endMoment.diff(startMoment, "seconds");

            if (span > 0) {
                if (span <= 60)
                    return Resolution.Full;
                if (span <= 120)
                    return Resolution.TenPerSecond;
                if (span <= 1800)
                    return Resolution.EverySecond;
                if (span <= 10800)
                    return Resolution.Every10Seconds;
                if (span <= 28800)
                    return Resolution.Every30Seconds;
                if (span <= 86400)
                    return Resolution.EveryMinute;
                if (span <= 604800)
                    return Resolution.Every10Minutes;
                if (span <= 1814400)
                    return Resolution.Every30Minutes;
                else
                    return Resolution.EveryHour;
            }
                        
            return Resolution.Full;
        }

        function getResolutionDescription(resolution) {
            switch (resolution) {
                case Resolution.Full:
                    return "Full";
                case Resolution.TenPerSecond:
                    return "Ten per Second";
                case Resolution.EverySecond:
                    return "Every Second";
                case Resolution.Every10Seconds:
                    return "Every 10 Seconds";
                case Resolution.Every30Seconds:
                    return "Every 30 Seconds";
                case Resolution.EveryMinute:
                    return "Every Minute";
                case Resolution.Every10Minutes:
                    return "Every 10 Minutes";
                case Resolution.Every30Minutes:
                    return "Every 30 Minutes";
                case Resolution.EveryHour:
                    return "Every Hour";
                case Resolution.EveryDay:
                    return "Every Day";
                case Resolution.EveryMonth:
                    return "Every Month";
            }

            return "Undefined Resolution: " + notNull(resolution);
        }

        function populateDataResolutionSelect() {
            const dataResolutionSelect = $("#trendResolution");

            for (let key in Resolution) {
                if (Resolution.hasOwnProperty(key)) {
                    const value = Resolution[key];
                    dataResolutionSelect.append($("<option>", { value: value, text: getResolutionDescription(value)}));
                }
            }
        }

        function postRecordRendering(elements, sequenceRecord) {
            const checkbox = $(elements).find("input[type=checkbox]");

            if (!checkbox)
                return;

            checkbox.click(function() {
                const record = viewModel.pageRecords()[checkbox.parents("tr")[0].rowIndex - 1];

                if (checkbox[0].checked)
                    viewModel.addNewSelectedPointByRecord(record);
                else
                    viewModel.deleteSelectedPointByRecord(record);

                $("#selectAllMessage").invisible();
            });

            // Allow up/down arrow keys to change focus between each row's checkbox
            checkbox.keydown(function(event) {
                if (event.which === 38) {
                    // Arrow up
                    const previousIndex = $(event.target).parents("tr")[0].rowIndex - 1;

                    if (previousIndex >= 0) {
                        const previous = $("#recordsTable").find("input[type=checkbox]:eq(" + previousIndex + ")");

                        if (!$.isEmptyObject(previous))
                            previous.focus();
                    }

                } else if (event.which === 40) {
                    // Arrow down
                    const nextIndex = $(event.target).parents("tr")[0].rowIndex + 1;

                    if (nextIndex <= viewModel.currentPageSize()) {
                        const next = $("#recordsTable").find("input[type=checkbox]:eq(" + nextIndex + ")");

                        if (!$.isEmptyObject(next))
                            next.focus();
                    }
                }
            });
        }

        function ExtendedViewModel() {
            const self = this;

            PagedViewModel.call(self);

            self.selectedPoints = ko.observableArray().extend({ deferred: true });

            self.addNewSelectedPoint = function(id, tag, signalType, description) {
                if (!self.selectedPoints().any(function(point) { return point.id === id }))
                    self.selectedPoints.push({ id: id, tag: tag, signalType: signalType, description: description });
            }

            self.deleteSelectedPoint = function(point) {
                self.selectedPoints.remove(point);
                $(self).trigger("selectedPointRemoved", point);
            }

            self.refreshSelectedPoints = function() {
                self.selectedPoints.valueHasMutated();
            }

            self.clearSelectedPoints = function() {
                const placeholder = $("#placeholder");
                self.selectedPoints([]);
                placeholder.empty();
                $("#selectAllMessage").invisible();
                $("#selectAllCheckbox")[0].checked = false;
                selectPageRecords(false);
            }

            self.addNewSelectedPointByRecord = function(record) {
                self.addNewSelectedPoint(record.PointID, record.PointTag, record.SignalType, record.Description);
            }

            self.deleteSelectedPointByRecord = function(record) {
                self.selectedPoints().any(function(point) {
                    if (point.id === record.PointID)
                        self.deleteSelectedPoint(point);
                });
            }

            self.getSelectedPointIDs = function() {
                var selectedPointIDs = [];

                self.selectedPoints().forEach(function(point) {
                    selectedPointIDs.push(point.id);
                });

                return selectedPointIDs;
            }

            self.getSeries = function(selectedPoint) {
                if (!plot)
                    return null;

                const series = plot.getData();

                if (!series)
                    return null;

                for (let i = 0; i < series.length; i++) {
                    const label = notNull(series[i].label);
                    const leftBracketIndex = label.indexOf("[");
                    const rightBracketIndex = label.indexOf("]");

                    if (leftBracketIndex > -1 && rightBracketIndex > -1) {
                        if (selectedPoint.id === parseInt(label.substring(leftBracketIndex + 1, rightBracketIndex)))
                            return { index: i, value: series[i] };
                    }
                }

                return null;
            }

            self.getSeriesColor = function(selectedPoint) {
                const series = self.getSeries(selectedPoint);

                if (!series)
                    return "transparent";

                return series.value.color;                    
            }

            self._startTime = ko.observable(moment.utc().subtract(5, "minutes").format(MomentDateTimeFormat));
            self._endTime = ko.observable(moment.utc().format(MomentDateTimeFormat));

            self.startTime = ko.pureComputed({
                read: function() {
                    return self._startTime();
                },
                write: function(value) {
                    self._startTime(value);

                    if (self.timeRange.isValid()) {
                        const startMoment = self.startMoment();
                        const endMoment = self.endMoment();

                        self.trendResolution(estimatePlotResolution(startMoment, endMoment));

                        if (self.dataHubIsConnected())
                            dataHub.getElapsedTimeString(startMoment.toDate(), endMoment.toDate()).done(function(elapsedTime) {
                                self.elapsedTime(elapsedTime);
                            });
                    } else {
                        self.elapsedTime("Invalid time range selected.");
                    }
                },
                owner: self
            });

            self.endTime = ko.pureComputed({
                read: function() {
                    return self._endTime();
                },
                write: function(value) {
                    self._endTime(value);

                    if (self.timeRange.isValid()) {
                        const startMoment = self.startMoment();
                        const endMoment = self.endMoment();

                        self.trendResolution(estimatePlotResolution(startMoment, endMoment));

                        if (self.dataHubIsConnected())
                            dataHub.getElapsedTimeString(startMoment.toDate(), endMoment.toDate()).done(function(elapsedTime) {
                                self.elapsedTime(elapsedTime);
                            });
                    } else {
                        self.elapsedTime("Invalid time range selected.");
                    }
                },
                owner: self
            });

            self.startMoment = ko.pureComputed({
                read: function() {
                    return moment.utc(self.startTime(), MomentDateTimeFormat);
                },
                owner: self
            });

            self.endMoment = ko.pureComputed({
                read: function() {
                    return moment.utc(self.endTime(), MomentDateTimeFormat);
                },
                owner: self
            });

            self.timeRange = ko.validatedObservable(
            [
                {
                    startTime: self.startTime.extend({
                        required: {
                            message: "<br />Start time is required"
                        },
                        validation: {
                            validator: function() {
                                return self.startMoment().diff(self.endMoment()) < 0;
                            },
                            message: "<br />Start time must be less than end time"
                        }
                    })
                }, {
                    endTime: self.endTime.extend({
                        required: {
                            message: "<br />End time is required"
                        },
                        validation: {
                            validator: function() {
                                return self.endMoment().diff(self.startMoment()) > 0;
                            },
                            message: "<br />End time must be greater than start time"
                        }
                    })
                }
            ]);

            self._alignTimestamps = ko.observable(true);
            self._useInterval = ko.observable(false);
            self._interval = ko.observable(5);
            self._intervalUnits = ko.observable(1);

            self.trendResolution = ko.observable(Resolution.EverySecond);
            self.trendSeriesLimit = ko.observable(500);
            self.elapsedTime = ko.observable("");
            self.fileFormat = ko.observable(0);
            self.frameRate = ko.observable(30);
            self.missingAsNaN = ko.observable(true);
            self.fillMissingTimestamps = ko.observable(false);
            self.selectAllProgress = ko.observable("0%");

            self.applyIntervalRange = function() {
                var intervalUnits = null;

                switch (parseInt(self.intervalUnits())) {
                    case 0:
                        intervalUnits = "seconds";
                        break;
                    case 1:
                        intervalUnits = "minutes";
                        break;
                    case 2:
                        intervalUnits = "hours";
                        break;
                    case 3:
                        intervalUnits = "days";
                        break;
                }

                if (!intervalUnits)
                    return;

                self.startTime(moment.utc().subtract(self.interval(), intervalUnits).format(MomentDateTimeFormat));
                self.endTime(moment.utc().format(MomentDateTimeFormat));
            }

            self.useInterval = ko.pureComputed({
                read: function() {
                    return self._useInterval();
                },
                write: function(value) {
                    self._useInterval(value);

                    if (value)
                        self.applyIntervalRange();
                },
                owner: self
            });

            self.interval = ko.pureComputed({
                read: function() {
                    return self._interval();
                },
                write: function(value) {
                    self._interval(value);
                    self.applyIntervalRange();
                },
                owner: self
            });

            self.intervalUnits = ko.pureComputed({
                read: function() {
                    return self._intervalUnits();
                },
                write: function(value) {
                    self._intervalUnits(value);
                    self.applyIntervalRange();
                },
                owner: self
            });

            self.alignTimestamps = ko.pureComputed({
                read: function() {
                    return self._alignTimestamps();
                },
                write: function(value) {
                    self._alignTimestamps(value);

                    if (!value)
                        self.fillMissingTimestamps(false);
                },
                owner: self
            });

            self.saveSelections = function(fileName) {
                const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(self.selectedPoints(), null, 4));
                const anchor = $("#saveSelectionsFileLink");

                if (typeof anchor[0].download != "undefined") {
                    anchor.attr("href", data);
                    anchor.attr("download", fileName);
                    anchor[0].click();
                } else {
                    window.open(data, "_blank", "");
                }
            }

            self.loadSelections = function(fileBlob) {
                var reader = new FileReader();

                reader.onload = function() {
                    self.clearSelectedPoints();
                    self.selectedPoints(JSON.parse(reader.result));
                }

                reader.onloadend = function() {
                    if (reader.error && reader.error.message)
                        showErrorMessage("Failed to load point selections: " + reader.error.message);
                };

                reader.readAsText(fileBlob);
            }

            self.sortSelections = function() {
                self.selectedPoints.sort(function(a, b) {
                    return a.id - b.id;
                });
            }
        }

        function extendViewModel(event, data) {
            const newViewModel = new ExtendedViewModel();
            data.viewModel.cloneConfiguration(newViewModel);
            data.viewModel = newViewModel;

            // Populate data resolution drop-down before binding
            populateDataResolutionSelect();

            ko.bindingHandlers.dateTimePicker = {
                init: function (element, valueAccessor, allBindingsAccessor) {
                    // Initialize datepicker with some basic options
                    const options = allBindingsAccessor().dateTimePickerOptions || { showClose: true, useCurrent: false, format: MomentDateTimeFormat };

                    $(element).datetimepicker(options);

                    // When user changes the date, update view model
                    ko.utils.registerEventHandler(element, "dp.change", function (event) {
                        const value = valueAccessor();

                        if (ko.isObservable(value)) {
                            if (event.date != null && !(event.date instanceof Date))
                                value(event.date.format(MomentDateTimeFormat));
                            else
                                value(event.date.formatDate(DateTimeFormat, true));
                        }
                    });

                    ko.utils.registerEventHandler(element, "dp.show", function (event) {
                        const picker = $(element).data("DateTimePicker");

                        if (picker)
                            picker.date(moment.utc(ko.utils.unwrapObservable(valueAccessor()), MomentDateTimeFormat));
                    });

                    ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                        const picker = $(element).data("DateTimePicker");

                        if (picker)
                            picker.destroy();
                    });
                }
            }

            ko.validation.init({
                registerExtenders: true,
                messagesOnModified: true,
                insertMessages: true,
                parseInputAttributes: true,
                allowHtmlMessages: true,
                messageTemplate: null,
                decorateElement: true,
                errorElementClass: "has-error",
                errorMessageClass: "help-block",
                grouping: { deep: true, observable: true, live: true }
            }, true);
        }

        $(window).on("beforeApplyBindings", extendViewModel);

        function refreshSeriesColors() {
            const selectedPointsTable = $("#selectedPoints")[0];

            viewModel.selectedPoints().forEach(function(point, index) {
                $(selectedPointsTable.rows[index].cells[1]).find("hr.series-color").css("background-color", viewModel.getSeriesColor(point));
            });
        }
    </script>
}
@section Scripts {
    <script src="Scripts/flot/jquery.flot.js"></script>
    <script src="Scripts/flot/jquery.flot.crosshair.js"></script>
    <script src="Scripts/flot/jquery.flot.navigate.js"></script>
    <script src="Scripts/flot/jquery.flot.resize.js"></script>
    <script src="Scripts/flot/jquery.flot.selection.js"></script>
    <script src="Scripts/flot/jquery.flot.time.js"></script>
    <script src="Scripts/flot/jquery.flot.axislabels.js"></script>
    <script>        
        "use strict";

        @Raw(dataContext.RenderViewModelConfiguration<ActiveMeasurement, DataHub>(ViewBag, "PointTag"))
        var plotData = [];
        var trendQueue = [];

        function getAxisIndex(signalType) {
            switch (signalType.toUpperCase().trim()) {
                case "FREQ":
                    return 1;
                case "VPHM":
                    return 2;
                case "IPHM":
                    return 3;
                case "VPHA":
                case "IPHA":
                    return 4;
            }

            return 2;
        }

        function buildPlot(data) {
            var elements = new Dictionary(); // Key = ID, Value = Array([Timestamp, Value])
            var elementData;
            plotData = [];

            $.each(data, function(i, trendValue) {
                // See if this is a newly encountered point
                if (elements.containsKey(trendValue.ID)) {
                    // Key already initialized, get element data for ID
                    elementData = elements.get(trendValue.ID);
                } else {
                    // Initialize new element data for ID
                    var point = null;
                    elementData = [];

                    // Find associated selected point
                    $.each(viewModel.selectedPoints(),
                        function(j, selectedPoint) {
                            if (selectedPoint.id === trendValue.ID) {
                                point = selectedPoint;
                                return false; // break
                            }

                            return true;
                        });

                    if (point) {
                        // Note that [n] in label is used to map label back to selected point for applying series color, so do not remove
                        plotData.push({ label: String.format("[{0}] {1} ({2})", point.id, point.tag, point.signalType), yaxis: getAxisIndex(point.signalType), data: elementData });
                        elements.set(trendValue.ID, elementData);
                    }
                }

                // Add measurement time and value to element data
                elementData.push([trendValue.Timestamp, trendValue.Value]);
            });

            const placeholder = $("#placeholder");
            const initialized = (plot !== undefined);

            plot = $.plot(placeholder, plotData,
            {
                series: {
                    shadowSize: 1,
                    lines: {
                        show: true
                    },
                    points: {
                        show: $("#showPoints")[0].checked
                    }
                },
                grid: {
                    hoverable: true,
                    clickable: true
                },
                yaxes: [
                    {
                        show: viewModel.selectedPoints().any(function(point) { return point.signalType === "FREQ" }),
                        position: "left",
                        axisLabel: "Frequency",
                        panRange: false,
                        zoomRange: false
                    }, {
                        show: viewModel.selectedPoints().any(function(point) { return point.signalType === "VPHM" }),
                        position: "left",
                        axisLabel: "Voltage",
                        panRange: false,
                        zoomRange: false
                    }, {
                        show: viewModel.selectedPoints().any(function(point) { return point.signalType === "IPHM" }),
                        position: "right",
                        axisLabel: "Current",
                        panRange: false,
                        zoomRange: false
                    }, {
                        show: viewModel.selectedPoints().any(function(point) { return point.signalType === "VPHA" || point.signalType === "IPHA" }),
                        position: "right",
                        axisLabel: "Angle",
                        panRange: false,
                        zoomRange: false
                    }
                ],
                xaxis: {
                    mode: "time",
                    timeformat: "%H:%M:%S",
                    timezone: "UTC",
                    reserveSpace: true,
                    zoomRange: [1, 3.154e+11]
                } ,
                legend: {
                    show: true
                },
                zoom: {
                    interactive: true,
                    mode: "x"
                },
                selection: {
                    mode: "x"
                }
            });

            if (!initialized)
                initializePlot(placeholder);
        }

        function getValidTimeRange(startDate, endDate) {
            const now = moment.utc();
            var startMoment = moment.utc(startDate);
            var endMoment = moment.utc(endDate);

            if (startMoment <= 0 || endMoment <= 0 || endMoment <= startMoment) {
                startMoment = now.subtract(1, "ms");
                endMoment = now;
            } else if (endMoment > now) {
                startMoment = startMoment.subtract(endMoment.diff(now));
                endMoment = now;
            }

            return {
                startDate: startMoment.toDate(),
                endDate: endMoment.toDate()
            };
        }

        function getRangeDifference(range) {
            return moment.utc(range.endDate).diff(moment.utc(range.startDate));
        }

        function compareRange(startRange, endRange) {
            return getRangeDifference(startRange) - getRangeDifference(endRange);
        }

        function initializePlot(placeholder) {
            placeholder.on("plotselected", function(event, ranges) {
                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();

                const range = getValidTimeRange(new Date(ranges.xaxis.from), new Date(ranges.xaxis.to));
                viewModel.startTime(range.startDate.formatDate());
                viewModel.endTime(range.endDate.formatDate());
                trendData();
            });

            //placeholder.on("plotpan", function(event, plot) {
            //    const axes = plot.getAxes();
            //    const range = getValidTimeRange(new Date(axes.xaxis.min), new Date(axes.xaxis.max));
            //    viewModel.startTime(range.startDate.formatDate());
            //    viewModel.endTime(range.endDate.formatDate());
            //    trendData();
            //});

            placeholder.on("plotzoom", function(event, plot, args) {
                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();

                const axes = plot.getAxes();
                var newRange = getValidTimeRange(new Date(axes.xaxis.min), new Date(axes.xaxis.max));
                const currentRange = getValidTimeRange(viewModel.startMoment(), viewModel.endMoment());
                const comparison = compareRange(newRange, currentRange);                
                const queueZoomForTrending = args.zoomingOut ? comparison >= 0 : comparison < 0;
                var resolution = null;

                if (!queueZoomForTrending) {
                    var startMoment = viewModel.startMoment();
                    const endMoment = viewModel.endMoment();
                    const amount = endMoment.diff(startMoment) / plot.getOptions().zoom.amount * 1.05;

                    if (args.zoomingOut)
                        startMoment = startMoment.subtract(amount);
                    else
                       startMoment = startMoment.add(amount);

                    newRange = getValidTimeRange(startMoment, endMoment);
                    resolution = estimatePlotResolution(startMoment, endMoment);
                }

                viewModel.startTime(newRange.startDate.formatDate());
                viewModel.endTime(newRange.endDate.formatDate());
                trendData(resolution);
            });

            placeholder.bind("plothover", function (event, pos, item) {
                if (item) {
                    const toolTipText = String.format("{0} at {1} = {2}", item.series.label, (new Date(item.datapoint[0])).formatDate(), item.datapoint[1].toFixed(2));
                    $("#plotToolTip").html(toolTipText).css({ top: item.pageY + 5, left: item.pageX + 5 }).fadeIn(200);
                } else {
                    $("#plotToolTip").hide();
                }
            });

            placeholder.bind("plotclick", function (event, pos, item) {
                if (item)
                    plot.highlight(item.series, item.datapoint);
            });

            //placeholder.dblclick(function() {
            //    resetZoom();
            //});

            placeholder.mouseleave(function() {
                $("#plotToolTip").hide();
            });

            placeholder.mousedown(function(e) {
                if (e.which !== 1)
                    return;

                if (e.shiftKey) {
                    plot.suspendSelection();

                    $(document).one("mouseup", function(e) {
                        if (e.which === 1)
                            plot.resumeSelection();
                    });
                }
            });
        }

        $(viewModel).on("selectedPointRemoved", function(event, point) {
            const series = viewModel.getSeries(point);

            if (series) {
                const plotData = plot.getData();
                plotData.splice(series.index, 1);
                plot.setData(plotData);
                plot.setupGrid();
                plot.draw();

                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();
            }
        });

        function displayTimeRange() {
            if (!hubIsConnected || !viewModel.timeRange.isValid())
                return;
            
            dataHub.getElapsedTimeString(viewModel.startMoment().toDate(), viewModel.endMoment().toDate()).done(function(elapsedTime) {
                viewModel.elapsedTime(elapsedTime);
            });
        }

        function processNextTrend() {
            if (trendQueue.length > 1) {
                trendQueue.shift();
                setTimeout(processNextTrend, 100);
                return;
            }

            const trend = trendQueue.pop();
            
            if (!trend)
                return;

            const startDate = trend.startDate;
            const endDate = trend.endDate;
            const resolution = trend.resolution;

            try {
                const selectedPointIDs = viewModel.getSelectedPointIDs();

                if (selectedPointIDs.length === 0)
                    return;

                $("html,body").addClass("busy-state");
                viewModel.useInterval(false);

                const queryStartTime = performance.now();

                dataHub.getHistorianData(startDate, endDate, selectedPointIDs, resolution, viewModel.trendSeriesLimit()).done(function(data) {
                    const graphStartTime = performance.now();

                    $("#queryTime").text((graphStartTime - queryStartTime).toFixed(3));

                    buildPlot(data);
                    plot.setData(plotData);
                    plot.setupGrid();
                    plot.draw();
                    refreshSeriesColors();

                    if (!$("#showLegend")[0].checked)
                        $(".legend").hide();

                    $("html,body").removeClass("busy-state");
                    $("#graphTime").text((performance.now() - graphStartTime).toFixed(3));
                    $("#pointCount").text(data.length);
                }).
                fail(function(error) {
                    showErrorMessage(error);
                    $("html,body").removeClass("busy-state");
                });
            }
            catch (ex) {
                showErrorMessage(ex.message);
                $("html,body").removeClass("busy-state");
            }
        }

        function queueTrend(startDate, endDate, resolution, timeout) {
            trendQueue.push({
                startDate: startDate,
                endDate: endDate,
                resolution: resolution
            });

            if (timeout)
                setTimeout(processNextTrend, timeout);
            else
                processNextTrend();
        }

        function trendData(selectedResolution) {
            if (!hubIsConnected)
                return;

            const startMoment = viewModel.startMoment();
            const endMoment = viewModel.endMoment();

            if (endMoment.diff(startMoment) <= 0)
                return;

            const startDate = startMoment.toDate();
            const endDate = endMoment.toDate();

            if (selectedResolution)
                queueTrend(startDate, endDate, selectedResolution);
            else
                queueTrend(startDate, endDate, estimatePlotResolution(startMoment, endMoment), 200);
        }

        function exportData() {
            if (!hubIsConnected)
                return;

            const selectedPointIDs = viewModel.getSelectedPointIDs();

            if (selectedPointIDs.length === 0)
                return;

            $("#exportDataLink").attr("href", "ExportDataHandler.ashx" +
                "?PointIDs=" + encodeURIComponent(selectedPointIDs.join()) + 
                "&StartTime=" + encodeURIComponent(viewModel.startTime()) + 
                "&EndTime=" + encodeURIComponent(viewModel.endTime()) + 
                "&FrameRate=" + encodeURIComponent(viewModel.frameRate()) + 
                "&AlignTimestamps=" + encodeURIComponent(viewModel.alignTimestamps()) + 
                "&MissingAsNaNParam=" + encodeURIComponent(viewModel.missingAsNaN()) + 
                "&FillMissingTimestamps=" + encodeURIComponent(viewModel.fillMissingTimestamps()));

            $("#exportDataLink")[0].click();
        }

        var baseCalculateRemainingBodyHeight;

        // Override remaining body height calculation to include new tab rows
        var calculateRemainingBodyHeight = (function() {
            baseCalculateRemainingBodyHeight = calculateRemainingBodyHeight;

            return function() {
                return baseCalculateRemainingBodyHeight() - $("#tabs ul").outerHeight(true);
            }
        })();

        function getActiveTab() {
            return $("#tabs").tabs("option", "active");
        }

        function resizeScreenObjects(refreshPageSize) {
            if (refreshPageSize === undefined)
                refreshPageSize = false;

            setTimeout(function() {
                const selectedPointsArea = $("#selectedPointsArea");

                if (getActiveTab() === 0)
                    selectedPointsArea.height($("#tabs").height() - 12);
                else
                    selectedPointsArea.height(baseCalculateRemainingBodyHeight());

                $("#scrollablePointsArea").height(selectedPointsArea.height() - $("#selectedPointsHeader").outerHeight(true) - 5);
            }, 300);

            const selectedPointsColumn = $("#selectedPointsColumn");
            const containerWidth = $("#bodyContainer").innerWidth();

            if (selectedPointsColumn.hasClass("in")) {
                let areaWidth = containerWidth * 0.2;

                if (areaWidth < 150)
                    areaWidth = 150;

                selectedPointsColumn.width(areaWidth);

                if (refreshPageSize) {
                    setTimeout(function() {
                        viewModel.calculatePageSize();
                        viewModel.refreshSelectedPoints();
                    }, 100);
                }
            }
            
            if (getActiveTab() === 1) {
                const placeholder = $("#placeholder");
                const height = calculateRemainingBodyHeight() - $("#trendTimeRangeSelection").outerHeight(true);
                const width = containerWidth - (selectedPointsColumn.hasClass("in") ? selectedPointsColumn.width() : 0);

                if (height !== placeholder.height() || width !== placeholder.width()) {
                    placeholder.height(height);
                    placeholder.width(width);
                }

                if (!$("#showLegend")[0].checked)
                    $(".legend").hide();
            }

            $("#plotToolTip").hide();
        }

        function showAdvancedTrendOptions() {
            $("#advancedTrendOptions").toggleClass("in");
            resizeScreenObjects();
        }

        function selectPageRecords(checked) {
            for (let i = 0; i < viewModel.pageRecords().length; i++) {
                const next = $("#recordsTable").find("input[type=checkbox]:eq(" + (i + 1) + ")");

                if (!$.isEmptyObject(next)) {
                    if (next[0].checked !== checked)
                        next.click();
                }
            }

            if (checked && viewModel.totalPages() > 1) {
                $("#selectAllProgress").invisible();
                cancelSelectAllRecords();
                $("#selectAllMessage").visible();
            }
        }

        var selectAllRecordsCanceled = false;

        function cancelSelectAllRecords() {
            selectAllRecordsCanceled = true;
        }

        function selectAllRecords() {
            $("#selectAllMessage").invisible();
            $("#tabs").tabs({ active: 0 });
            $("a[href='#tab1']").parent().focus();

            if (!viewModel.dataHubIsConnected())
                return;

            const totalPages = viewModel.totalPages();
            const sortField = viewModel.sortField();
            const sortAscending = viewModel.sortAscending();
            const currentPageSize = viewModel.currentPageSize();
            const filterText = viewModel.filterText;
            var processedPages = 0;

            selectAllRecordsCanceled = false;
            viewModel.selectAllProgress("0%");

            $("#selectAllProgressCancel").text("Cancel");
            $("#selectAllProgress").visible();

            function queryRecords(page, lastPage) {
                viewModel.queryRecords(sortField, sortAscending, page, currentPageSize, filterText).done(function(records) {
                    if (!selectAllRecordsCanceled) {
                        records.forEach(function(record) {
                            viewModel.addNewSelectedPointByRecord(record);
                            return !selectAllRecordsCanceled;
                        });
                    }

                    viewModel.selectAllProgress(String.format("{0}%", (++processedPages / totalPages * 100).truncate()));

                    if (lastPage) {
                        $("#selectAllProgressCancel").text("Done!");

                        setTimeout(function() {
                           $("#selectAllProgress").invisible();
                        }, 2000);
                    }
                }).
                fail(function(error) {
                    showErrorMessage(error);

                    if (lastPage)
                        $("#selectAllProgress").invisible();
                });;
            }

            for (let page = 1; page <= totalPages && !selectAllRecordsCanceled; page++)
                queryRecords(page, page === totalPages);

            if (selectAllRecordsCanceled)
                $("#selectAllProgressCancel").text("Canceled!");
        }

        $(function() {
            $("#tabs").tabs({
                active: 0,
                activate: function(event, ui) {
                    const searchHeader = $("#searchFilter").parents(".form-group");
                    const recordCount = $("#titleText");

                    switch (ui.newPanel.attr("id")) {
                        case "tab1":
                            searchHeader.show();
                            recordCount.show();
                            viewModel.calculatePageSize();
                            $("#plotToolTip").hide();
                            break;
                        case "tab2":
                            searchHeader.hide();
                            recordCount.hide();
                            $("#selectAllMessage").invisible();
                            displayTimeRange();
                            break;
                        case "tab3":
                            searchHeader.hide();
                            recordCount.hide();
                            $("#selectAllMessage").invisible();
                            $("#plotToolTip").hide();
                            displayTimeRange();
                            break;
                    }

                    resizeScreenObjects();
                }
            });

            $("#selectedPointsColumn").on("shown.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#selectedPointsColumn").on("hidden.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#trendTimeRangeSelection").on("shown.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $("#trendTimeRangeSelection").on("hidden.bs.collapse", function() {
                resizeScreenObjects(true);
            });

            $(viewModel).on("pageSizeCalculated", function() {
                resizeScreenObjects(false);
            });

            $(viewModel).on("pageRecordsQueried", function() {
                $("#selectAllMessage").invisible();
            });

            $(window).resize(resizeScreenObjects);

            resizeScreenObjects();

            const selectAllCheckbox = $("#selectAllCheckbox");
            
            selectAllCheckbox.click(function() {
                selectPageRecords(selectAllCheckbox[0].checked);
            });

            selectAllCheckbox.keydown(function(event) {
                if (event.which === 40) {
                    // Arrow down
                    if (viewModel.currentPageSize() > 0) {
                        const next = $("#recordsTable").find("input[type=checkbox]:eq(1)");

                        if (!$.isEmptyObject(next))
                            next.focus();
                    }
                }
            });

            $(viewModel).on("pageRecordsQueried", function() {
                selectAllCheckbox[0].checked = false;
            });

            ko.watch(viewModel.currentPage, function(parents, child, item) {
                $("#selectAllMessage").invisible();
            });

            $("<div id='plotToolTip'></div>").css({
                position: "absolute",
                display: "none",
                border: "1px solid #fdd",
                padding: "2px",
                "background-color": "#fee",
                opacity: 0.80
            }).appendTo("body");

            $("#selectedPointsColumn").mouseenter(function() {
                $("#plotToolTip").hide();
            });

            const showLegend = $("#showLegend");
            var lastShowLegendState = Cookies.get("trendShowLegend");

            if (lastShowLegendState === undefined)
                lastShowLegendState = "true";

            showLegend.prop("checked", lastShowLegendState === "true");

            showLegend.click(function() {
                $(".legend").toggle();
                Cookies.set("trendShowLegend", this.checked.toString(), { expires: 365 });
            });

            // Setup save selections file name dialog functionality
            $("#saveSelectionsFile").click(function() {
                $("#saveSelectionsFileNameDialog").hide();

                var fileName = notNull($("#inputSelectionsFileName").val());

                if (fileName.length === 0)
                    fileName = "SelectedPoints.json";

                if (!fileName.endsWith(".json"))
                    fileName += ".json";

                viewModel.saveSelections(fileName);
            });

            // Make enter key auto-click save
            $("#inputSelectionsFileName").keyup(function(event) {
                if (event.keyCode === 13)
                    $("#saveSelectionsFile").click();
            });

            // Auto-select all text on focus
            $("#inputSelectionsFileName").focus(function() {
                $(this).select();
            });

            // Prevent default form submission when user presses enter
            $("#saveSelectionsFileNameDialog").submit(function() {
                return false;
            });

            // Auto-hide pop-up form when user clicks outside form area
            $("#saveSelectionsFileNameDialog").focusout(function() {
                if (!$("#saveSelectionsFileNameDialog").is(":hover") && !$("#showSaveSelectionsFileNameDialog").is(":hover"))
                    $("#saveSelectionsFileNameDialog").hide();
            });
        });
        
        function showSaveSelectionsFileNameDialog() {
            $("#saveSelectionsFileNameDialog").toggle();

            if ($("#saveSelectionsFileNameDialog").is(":visible"))
                $("#inputSelectionsFileName").focus();
        }

        function showLoadSelectionsFileNameDialog() {
            $("#loadSelectionsFileName").trigger("click");
        }

        function loadSelectionsFile(event) {
            viewModel.loadSelections(event.target.files[0]);
            $("#loadSelectionsFileName").val("");
        }

        function cleanupTagName(tagName) {
            var cleanedTagName = notNull(tagName).trim();
            const prefixIndex = cleanedTagName.lastIndexOf("!");

            if (prefixIndex > -1 && prefixIndex < cleanedTagName.length - 1)
                cleanedTagName = cleanedTagName.substr(prefixIndex + 1);

            return cleanedTagName.truncate(25);
        }        
    </script>
}
<table>
    <tr>
        <td id="selectedPointsColumn" style="width: 20%; vertical-align: top; padding-right: 3px" class="collapse in">
            <div id="selectedPointsArea" class="well" style="padding: 5px">
                <div id="selectedPointsHeader" class="clearfix">
                    Selected Points&nbsp;<span data-bind="text: selectedPoints().length"></span><br/>
                    <button type="button" class="btn btn-sm" onclick="showSaveSelectionsFileNameDialog()" id="showSaveSelectionsFileNameDialog" data-bind="enable: selectedPoints().length > 0">Save</button>
                    <div class="well well-sm floating-form" id="saveSelectionsFileNameDialog" style="z-index: 1000">
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <button type="button" class="close" onclick="$('#saveSelectionsFileNameDialog').hide()" style="margin-top: -13px; margin-left: 8px">&times;</button>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="inputSelectionsFileName" placeholder="File name..." />
                                    <span class="input-group-btn">
                                        <button type="button" class="btn btn-default btn-sm" id="saveSelectionsFile" style="margin-right: -3px; font-weight: bold">Save</button>
                                    </span>
                                </div>
                            </div>
                        </form>
                    </div>
                    <a href="#" id="saveSelectionsFileLink" target="_blank" style="display: none"></a>
                    <button type="button" class="btn btn-sm" onclick="showLoadSelectionsFileNameDialog()">Load</button>
                    <input id="loadSelectionsFileName" type="file" accept="text/json" style="position: fixed; top: -100em" onchange="loadSelectionsFile(event)">
                    <button type="button" class="btn btn-sm" data-bind="click: sortSelections">Sort</button>
                    <button type="button" class="btn btn-sm pull-right" data-bind="click: clearSelectedPoints.bind($data)">Clear All</button>
                </div>
                <div id="scrollablePointsArea">
                    <table class="table table-striped table-bordered table-hover table-condensed">
                        <tbody id="selectedPoints" data-bind="foreach: selectedPoints">
                            <tr>
                                <td style="width: 5%" class="text-center valign-middle" data-bind="text: id"></td>
                                <td style="width: 90%" class="table-cell-hard-wrap">
                                    <span class="fixed-font" data-bind="text: cleanupTagName(tag), attr: { title: String.format('{0}: {1} - {2}', signalType, tag, description) }"></span>
                                    <hr class="series-color" data-bind="style: { 'background-color': $parent.getSeriesColor($data) }" />
                                </td>
                                <td style="width: 5%" class="text-center valign-middle"><button type="button" class="btn btn-xs" title="Unselect Point" data-bind="click: $parent.deleteSelectedPoint"><span class="glyphicon glyphicon-remove"></span></button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </td>
        <td id="tabsColumns" style="width: 80%; vertical-align: top">
            <div id="tabs" class="tabs-nohdr">
                <ul>
                    <li>
                        <button type="button" class="btn btn-xs btn-collapsable" id="collapseSelectedPoints" data-toggle="collapse" data-target="#selectedPointsColumn"></button>
                        <a href="#tab1">Select Points</a>
                    </li>
                    <li><a href="#tab2">Trend Data</a></li>
                    <li>
                        <a href="#tab3">Export Data</a>
                        <span id="selectAllMessage" style="visibility: hidden">Selected <span data-bind="text: pageRecords().length"></span> points on the current page, <a class="active" onclick="selectAllRecords()">click here</a> to select all <span data-bind="text: recordCount"></span> points on all pages.</span>
                        <div class="input-group" id="selectAllProgress" style="visibility: hidden">
                            <span style="display: table-cell; font-size: small">Selecting&nbsp;Points:&nbsp;</span>                            
                            <div class="progress" style="width: 180px; height: 22px">
                                <div class="progress-bar-info" id="selectAllProgressBar" role="progressbar" data-bind="style: { 'width': selectAllProgress }"><span data-bind="text: selectAllProgress">0%</span> Complete...</div>
                            </div>
                            <span class="input-group-btn">
                                <button class="btn btn-secondary" id="selectAllProgressCancel" type="button" onclick="cancelSelectAllRecords()">Cancel</button>
                            </span>
                        </div>
                    </li>
                </ul>
                <div id="tab1" class="ui-tabs-active">
                    @Html.RenderResource("GSF.Web.Model.Views.PagedViewModel.cshtml")
                </div>
                <div id="tab2">
                    <button type="button" class="btn btn-xs btn-collapsable pull-right" id="collapseTrendSetup" data-toggle="collapse" data-target="#trendTimeRangeSelection"></button>
                    <div class="well collapse in clearfix" style="padding: 10px 20px 10px 20px" id="trendTimeRangeSelection">
                        @Raw(string.Format(Include("SelectTimeRange.cshtml").ToString(), "plot").Trim())
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <label for="trendResolution">Data Resolution:</label>
                                <select class="form-control" id="trendResolution" data-bind="value: trendResolution" style="width: 150px"></select>
                                &nbsp;&nbsp;&nbsp;
                            </div>
                            <div class="checkbox">
                                <label for="showAdvanced"><input type="checkbox" id="showAdvanced" onclick="showAdvancedTrendOptions()"> Advanced&nbsp;Options</label>
                            </div>
                        </form>
                        <form class="form-inline collapse" id="advancedTrendOptions" role="form">
                            <hr class="quarter-break" />
                            <div class="form-group form-group-sm">
                                <label for="trendSeriesLimit">Series Limit<sup>*</sup>:</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" id="trendSeriesLimit" style="width: 65px" data-bind="textInput: trendSeriesLimit">
                                    <span class="input-group-addon">values per selected point</span>
                                </div>
                            </div>
                            <hr class="quarter-break" />
                            <div style="max-width: 600px">
                                <table>
                                    <tr>
                                        <td style="vertical-align: top"><sup>*</sup></td>
                                        <td>
                                            <em class="small">
                                                Series limit can be set to zero to trend all data values, however, for large data windows
                                                this could have severe performance implications.
                                            </em>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                        </form>
                        <hr class="thick-spacer">
                        <form class="form-inline" role="form" onsubmit="return false">
                            <button class="btn btn-primary pull-right" onclick="trendData(viewModel.trendResolution())" hub-dependent>Trend</button>
                            <div class="checkbox pull-right" style="margin-top: 5px">
                                <label for="showPoints"><input type="checkbox" id="showPoints" onclick="trendData()" hub-dependent> <strong>Show&nbsp;Points</strong></label>
                                &nbsp;&nbsp;
                            </div>
                            <div class="checkbox pull-right" style="margin-top: 5px">
                                <label for="showLegend"><input type="checkbox" id="showLegend"> <strong>Show&nbsp;Legend</strong></label>
                                &nbsp;&nbsp;
                            </div>
                        </form>
                    </div>
                    <div id="placeholder" style="width: 100%;"></div>
                    <span class="pull-right" style="font-size: x-small; color: lightgray; margin-top: 10px">
                        <span>Round-trip query time: <span id="queryTime"></span>ms</span>&nbsp;&nbsp;
                        <span>Graph generation time: <span id="graphTime"></span>ms</span>&nbsp;&nbsp;
                        <span>Total processed points: <span id="pointCount"></span></span>&nbsp;&nbsp;
                    </span>
                </div>
                <div id="tab3">
                    <div class="well clearfix" style="padding: 10px 20px 10px 20px" id="exportTimeRangeSelection">
                        @Raw(string.Format(Include("SelectTimeRange.cshtml").ToString(), "export").Trim())
                        <form class="form-inline" role="form">
                            <div class="form-group form-group-sm">
                                <label for="exportFileFormat">File Format:</label>
                                <select class="form-control" id="exportFileFormat" data-bind="value: fileFormat">
                                    <option value="0" selected>Comma Separated Values (CSV)</option>
                                    <option value="1" disabled>COMTRADE (ASCII)</option>
                                    <option value="2" disabled>COMTRADE (Binary)</option>
                                </select>
                                &nbsp;&nbsp;
                            </div>
                            <div class="form-group form-group-sm">
                                <label for="exportFrameRate">Frame Rate:</label>
                                <div class="input-group">
                                    <input type="number" class="form-control" id="exportFrameRate" style="width: 65px" data-bind="integer, textInput: frameRate">
                                    <span class="input-group-addon">frames per second</span>
                                </div>
                            </div>
                        </form>
                        <hr class="quarter-break" />
                        <form class="form-inline" role="form">
                            <div class="checkbox">
                                <label for="exportAlignTimestamps"><input type="checkbox" id="exportAlignTimestamps" data-bind="checked: alignTimestamps"> <strong>Align&nbsp;Timestamps</strong></label>
                            </div>
                            &nbsp;&nbsp;
                            <div class="checkbox">
                                <label for="exportMissingAsNaN"><input type="checkbox" id="exportMissingAsNaN" data-bind="checked: missingAsNaN"> <strong>Export&nbsp;Missing Values&nbsp;as&nbsp;NaN</strong></label>
                            </div>
                            &nbsp;&nbsp;
                            <div class="checkbox">
                                <label for="exportFillMissingTimestamps" data-bind="css: { 'disabled': !alignTimestamps()}"><input type="checkbox" id="exportFillMissingTimestamps" data-bind="checked: fillMissingTimestamps, enable: alignTimestamps"> <strong>Fill-in&nbsp;Missing Timestamps</strong><sup>*</sup></label>
                            </div>
                            &nbsp;&nbsp;
                        </form>
                        <hr class="quarter-break"/>
                        <div style="max-width: 600px">
                            <table>
                                <tr>
                                    <td style="vertical-align: top"><sup>*</sup></td>
                                    <td>
                                        <em class="small">
                                            Export timestamps with monotonically increasing time based on frame rate with no missing rows, i.e.,
                                            when no data is archived for a timestamp, write a blank row and don’t skip times.
                                        </em>
                                    </td>
                                </tr>
                            </table>
                        </div>
                        <hr class="thick-spacer">
                        <button class="btn btn-primary pull-right" onclick="exportData()">Export</button>
                        <a id="exportDataLink" download="" hidden=""></a>
                    </div>
                </div>
            </div>
        </td>
    </tr>
</table>